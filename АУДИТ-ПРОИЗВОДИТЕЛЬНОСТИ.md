# Аудит производительности мини-приложения

**Обновлено после оптимизаций (2025-02-15)**

## TL;DR

**Главные проблемы:** тяжёлые скрипты при старте (Tesseract ~2MB не используется), Supabase, 4 внешних CDN, цепочка последовательных запросов к Supabase при загрузке, ~3380 строк JS в одном файле.

**Приоритет правок:**
1. Убрать Tesseract.js из загрузки (не используется, экономия ~2MB)
2. Отложить загрузку Supabase или заменить на более лёгкий клиент
3. Параллелить запросы к Supabase при инициализации
4. Ленивая загрузка Tesseract (если решишь вернуть fallback)
5. Показать скелетон при загрузке, не блокировать рендер

---

## 1. Загрузка скриптов при старте

### Что загружается в `<head>` (блокирует рендер):

| Скрипт | Размер (прибл.) | Используется при старте? |
|--------|-----------------|--------------------------|
| `telegram-web-app.js` | ~15 KB | Да |
| `@supabase/supabase-js@2` | ~150–200 KB | Да (инициализация клиента) |
| `lz-string` | ~10 KB | Да (pack/unpack payload) |
| `tesseract.js` | ~63 KB + worker 111 KB + rus+eng языки ~2MB | **Нет** |

### Проблема: Tesseract не используется

- `CV_API_PRIORITY = ['openrouter', 'groq', 'gemini']` — Tesseract не в списке.
- Код `analyzeImageWithTesseract`, `analyzeImageWithOCRAPI`, `analyzeImageWithOpenAI` есть, но в production не вызывается.
- **Tesseract грузится на каждое открытие** (в т.ч. главной), хотя анализ идёт только через OpenRouter/Groq/Gemini.
- При первом вызове Tesseract тянет worker + wasm + языковые данные (~2MB+).

**Действие:** удалить `<script src="...tesseract.min.js">` — даст заметное ускорение (~2MB меньше при открытии с фото).

---

## 2. Последовательность загрузки при старте

### Текущий поток

1. HTML парсится → блокируется 4 скриптами в `<head>`.
2. `init()` → сразу `render()` с пустыми данными.
3. `loadAll()` запускается, ждём до 8 сек (Promise.race с таймаутом).
4. **Supabase (при useSupabase):** цепочка запросов:
   - `ensureUser()` — upsert в `users`
   - `loadWishlistsFromSupabase()` — 4–6 последовательных запросов:
     - wishlists (owned)
     - wishlist_collaborators
     - wishlists (shared)
     - wishlist_collaborators (all)
     - followed_public_wishlists
     - wishlists (followed)
   - `loadWishesFromSupabase()` — 2–3 запроса
   - `loadCategoriesFromSupabase()` — 1 запрос
5. После `loadAll()` — второй `render()` с данными.

### Проблемы

- **Водопад запросов:** часть можно выполнять параллельно (owned + collab + followed и т.п.).
- **Нет скелетона:** пользователь видит пустой экран, пока не завершится `loadAll()`.
- **8 сек таймаут:** при медленной сети долго ждём, потом fallback.

---

## 3. Структура кода и легаси

### Неиспользуемый / редко используемый код

| Компонент | Статус |
|-----------|--------|
| `analyzeImageWithTesseract` | Не вызывается (нет в CV_API_PRIORITY) |
| `analyzeImageWithOCRAPI` | Не вызывается |
| `analyzeImageWithOpenAI` | Не вызывается |
| `getImageFromTelegram` (по file_id) | Используется только если бот передаёт file_id, сейчас — img_url_ |
| `CV_API_PRIORITY \|\| ['tesseract', ...]` | Мёртвая ветка — CV_API_PRIORITY всегда задан |

### Размер

- `index.html`: ~3380 строк, ~150+ KB (HTML + CSS + JS в одном файле).
- Один большой inline-скрипт — долгий парсинг на слабых устройствах.

---

## 4. Анализ изображений

- Цепочка: OpenRouter → Groq → Gemini (по таймауту 30 сек на каждый).
- При падении первого провайдера ждём 30 сек до следующего.
- Картинка через прокси: 1 запрос к `/image-proxy`, потом fetch к Vision API.
- Оптимизации: сжатие перед отправкой, один провайдер по умолчанию, сокращение таймаута для fallback.

---

## 5. Рекомендации по приоритету

### Высокий приоритет (сразу)

1. **Удалить Tesseract из `<head>`**
   - Убрать `<script src="...tesseract.min.js">`.
   - Удалить или закомментировать ветку `api === 'tesseract'` в `analyzeImageWithCV`.
   - Эффект: −2MB при первом открытии, быстрее загрузка главной.

2. **Показать скелетон при загрузке**
   - В `init()` сразу рендерить заглушку (кнопки + «Загрузка…») вместо пустого контента.
   - Не ждать `loadAll()` для первого отображения UI.
   - Эффект: субъективно быстрее, нет «белого экрана».

### Средний приоритет (1–2 дня)

3. **Параллелить запросы Supabase в `loadWishlistsFromSupabase`**
   - Запускать независимые запросы через `Promise.all`:
     - owned + collab — параллельно;
     - shared + allCollab — после получения collabIds;
     - followed — параллельно с остальными где возможно.
   - В `loadAll()`: `ensureUser` + `loadWishlistsFromSupabase` + `loadCategoriesFromSupabase` частично параллельно.
   - Эффект: сокращение времени загрузки на 30–50%.

4. **Отложенная загрузка Supabase**
   - Подключать `supabase-js` только при `useSupabase` и после первого рендера (например, `import()` или динамический `<script>`).
   - Либо использовать только REST API для критичных запросов вместо полного клиента.
   - Эффект: быстрее первый рендер, меньше блокировки основного потока.

5. **Ленивая загрузка lz-string**
   - Используется только при hash (#w/, #i/, payload). Подключать динамически при разборе hash.
   - Эффект: небольшой, но даёт минус один скрипт в критическом пути.

### Низкий приоритет (по желанию)

6. **Удалить неиспользуемые анализаторы**
   - Удалить `analyzeImageWithTesseract`, `analyzeImageWithOCRAPI`, `analyzeImageWithOpenAI` или вынести в отдельный чанк, если захочешь оставить fallback.

7. **Разбить index.html**
   - Вынести JS в отдельные файлы, добавить сборку (Vite/rollup) и code splitting.
   - Эффект: меньше парсится при старте, возможна ленивая загрузка экранов.

8. **Виртуализация списков**
   - При большом количестве карточек — рендерить только видимые (react-window, virtuoso или аналог).
   - Эффект: важен только при 50+ карточках в одном вишлисте.

9. **Сократить таймауты Vision API**
   - С 30 до 15–20 сек для fallback.
   - Эффект: меньше ожидание при сбое провайдера.

---

## 6. Оценка эффекта

| Оптимизация | Ожидаемый выигрыш |
|-------------|-------------------|
| Убрать Tesseract | −2MB трафика, −1–2 сек до интерактивности |
| Скелетон при загрузке | Улучшение UX, «мгновенный» отклик |
| Параллельные запросы Supabase | −0.5–1.5 сек до появления данных |
| Отложенный Supabase | −0.3–0.5 сек до первого рендера |
| Удаление мёртвого кода | −~15 KB, чуть быстрее парсинг |

---

## 7. Выполненные оптимизации (2025-02-15)

- [x] Удалён Tesseract полностью
- [x] Отложенная загрузка Supabase (динамический `loadScript`)
- [x] Параллельные запросы Supabase (`Promise.all` в `loadWishlistsFromSupabase` и `loadAll`)
- [x] Скелетон при загрузке (анимация до появления данных)
- [x] Таймаут loadAll: 8 с → 5 с
- [x] Таймаут Vision API: 30 с → 12 с
- [x] Удалены `analyzeImageWithOCRAPI`, `analyzeImageWithOpenAI`, `getImageFromTelegram`
- [x] Ленивая загрузка lz-string (`ensureLzString` перед `loadAll`)
- [x] `content-visibility: auto` для `.card` и `.wl-item` (виртуализация)
- [ ] Разбиение index.html на файлы — отложено (можно вынести CSS в `styles.css` вручную)

## 8. Что делать дальше (если нужно)

Рекомендуемый порядок:

1. Удалить Tesseract и связанную ветку в `analyzeImageWithCV`.
2. Добавить скелетон в `init()`.
3. Распараллелить запросы в `loadWishlistsFromSupabase` и `loadAll()`.

После этого можно замерять загрузку и при необходимости браться за отложенную загрузку Supabase и рефакторинг структуры.
