<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Вишлист</title>
  <link rel="icon" href="data:,">
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/lz-string@1.5.0/libs/lz-string.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <style>
    :root {
      --bg-primary: #1a1a2e;
      --bg-secondary: #16213e;
      --bg-card: #0f3460;
      --accent: #e94560;
      --text-primary: #eaeaea;
      --text-secondary: #a0a0a0;
      --border: rgba(255,255,255,0.1);
      --shadow: 0 4px 20px rgba(0,0,0,0.3);
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      color: var(--text-primary);
      min-height: 100vh;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }
    body.light {
      --bg-primary: #f5f5f7;
      --bg-secondary: #ffffff;
      --bg-card: #ffffff;
      --text-primary: #1d1d1f;
      --text-secondary: #6e6e73;
      --border: rgba(0,0,0,0.1);
      --shadow: 0 4px 20px rgba(0,0,0,0.08);
    }
    .container { max-width: 480px; margin: 0 auto; padding: 16px; }
    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px 0 20px;
      border-bottom: 1px solid var(--border);
    }
    h1 { font-size: 1.5rem; font-weight: 700; }
    .btn {
      background: var(--accent);
      color: white;
      border: none;
      padding: 10px 18px;
      border-radius: 12px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.1s;
    }
    .btn:active { transform: scale(0.97); }
    .btn-secondary {
      background: var(--bg-card);
      color: var(--text-primary);
      border: 1px solid var(--border);
    }
    .btn-sm { font-size: 0.8rem; padding: 6px 12px; }
    .btn-icon {
      width: 40px; height: 40px; padding: 0;
      border-radius: 50%;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
    }
    .header-actions { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    .edit-cats-btn, .edit-wl-btn {
      font-size: 0.8rem;
      padding: 6px 10px;
      color: var(--text-secondary);
      background: transparent;
      border: 1px dashed var(--border);
    }
    .wl-section {
      margin-bottom: 24px;
      border: 1px solid var(--border);
      border-radius: 16px;
      overflow: hidden;
      background: var(--bg-card);
    }
    .wl-section-header {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid var(--border);
      min-height: 52px;
    }
    .wl-section-img {
      width: 40px;
      height: 40px;
      object-fit: cover;
      border-radius: 8px;
      background: var(--bg-secondary);
    }
    .wl-section-title { font-weight: 600; font-size: 1rem; }
    .wl-section-body { padding: 12px 16px; }
    .categories-section { margin: 20px 0; }
    .category-title {
      font-size: 0.9rem;
      color: var(--text-secondary);
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .category-title .count { font-weight: 600; color: var(--text-primary); }
    .wishlist { margin-top: 12px; }
    .card {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 12px;
      box-shadow: var(--shadow);
      border: 1px solid var(--border);
    }
    .card-img {
      width: 100%;
      height: 160px;
      object-fit: cover;
      border-radius: 12px;
      margin-bottom: 12px;
      background: var(--bg-secondary);
    }
    .card-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 8px; word-break: break-word; }
    .card-meta { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 4px; }
    .card-price { font-size: 1.2rem; font-weight: 700; color: var(--accent); margin-bottom: 6px; }
    .card-link {
      font-size: 0.8rem;
      color: var(--text-secondary);
      text-decoration: none;
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    .card-comment { font-size: 0.9rem; margin-top: 8px; opacity: 0.9; }
    .card-actions {
      display: flex;
      gap: 8px;
      margin-top: 12px;
      flex-wrap: wrap;
      align-items: center;
    }
    .card-move-wrap { position: relative; }
    .card-move-btn { padding: 6px 10px; font-size: 0.8rem; }
    .card-move-menu {
      position: absolute;
      bottom: 100%;
      left: 0;
      margin-bottom: 4px;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 4px 0;
      min-width: 160px;
      z-index: 10;
      box-shadow: var(--shadow);
    }
    .card-move-menu button {
      display: block;
      width: 100%;
      padding: 8px 12px;
      text-align: left;
      background: none;
      border: none;
      color: var(--text-primary);
      font-size: 0.9rem;
      cursor: pointer;
    }
    .card-move-menu button:hover { background: var(--bg-card); }
    .empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--text-secondary);
    }
    .empty-state p { margin-bottom: 16px; }
    .empty-cats { font-size: 0.9rem; color: var(--text-secondary); margin-top: 8px; }
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.6);
      display: flex;
      align-items: flex-end;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: 0.3s;
    }
    .modal-overlay.open { opacity: 1; visibility: visible; }
    .modal {
      background: var(--bg-secondary);
      border-radius: 24px 24px 0 0;
      width: 100%;
      max-width: 480px;
      max-height: 90vh;
      overflow-y: auto;
      padding: 24px;
      transform: translateY(100%);
      transition: transform 0.3s;
    }
    .modal-overlay.open .modal { transform: translateY(0); }
    .modal h2 { margin-bottom: 20px; font-size: 1.25rem; }
    .form-group { margin-bottom: 16px; }
    .form-group label {
      display: block;
      font-size: 0.85rem;
      color: var(--text-secondary);
      margin-bottom: 6px;
    }
    .form-group label .required { color: var(--accent); }
    .form-group input, .form-group select, .form-group textarea {
      width: 100%;
      padding: 12px 16px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--bg-card);
      color: var(--text-primary);
      font-size: 1rem;
    }
    .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
      outline: none;
      border-color: var(--accent);
    }
    .form-group textarea { min-height: 80px; resize: vertical; }
    .form-row { display: flex; gap: 12px; }
    .form-row .form-group { flex: 1; }
    .form-row .form-group:last-child { flex: 0 0 100px; }
    .img-upload {
      border: 2px dashed var(--border);
      border-radius: 12px;
      padding: 24px;
      text-align: center;
      cursor: pointer;
      transition: border-color 0.2s;
    }
    .img-upload:hover, .img-upload.dragover { border-color: var(--accent); }
    .img-upload input { display: none; }
    .img-preview {
      max-width: 100%;
      max-height: 200px;
      border-radius: 12px;
      margin-top: 12px;
    }
    .form-actions { display: flex; gap: 12px; margin-top: 24px; }
    .form-actions .btn { flex: 1; }
    .error-msg { font-size: 0.8rem; color: var(--accent); margin-top: 4px; }
    .cat-list { margin-top: 12px; }
    .cat-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      background: var(--bg-card);
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .cat-item-remove { color: var(--accent); cursor: pointer; padding: 4px; }
    .cat-add { display: flex; gap: 8px; margin-top: 12px; }
    .cat-add input { flex: 1; }
    .wl-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px;
      background: var(--bg-card);
      border-radius: 8px;
      margin-bottom: 8px;
      border: 1px solid var(--border);
    }
    .wl-item-img {
      width: 48px;
      height: 48px;
      object-fit: cover;
      border-radius: 8px;
      background: var(--bg-secondary);
    }
    .wl-item-body { flex: 1; }
    .wl-item-remove { color: var(--accent); cursor: pointer; padding: 4px; }
    .wl-item-edit { color: var(--text-secondary); cursor: pointer; padding: 4px; font-size: 0.9rem; }
    .wl-add-img { min-height: 80px; overflow: hidden; display: flex; align-items: center; justify-content: center; flex-direction: column; }
    .wl-add-img .img-preview { max-width: 100%; max-height: 120px; object-fit: contain; margin-top: 0; }
    .wl-header-actions { margin-left: auto; display: flex; gap: 8px; align-items: center; }
    .privacy-badge { font-size: 0.7rem; padding: 2px 6px; border-radius: 6px; background: var(--border); color: var(--text-secondary); }
    .card-reserved { opacity: 0.85; border-left: 3px solid var(--accent); }
    .card-reserved-badge { font-size: 0.8rem; color: var(--accent); margin-top: 6px; }
    .view-readonly .btn-edit, .view-readonly .btn-del, .view-readonly .btn-move { display: none !important; }
    .main-buttons { display: flex; flex-direction: column; gap: 12px; margin-bottom: 32px; }
    .main-buttons .btn { width: 100%; justify-content: center; }
    .section-title { font-size: 1rem; color: var(--text-secondary); margin-bottom: 12px; }
    .recent-list { display: flex; flex-direction: column; gap: 8px; }
    .recent-item {
      display: flex; align-items: center; gap: 12px;
      padding: 14px 16px; background: var(--bg-card); border-radius: 12px;
      border: 1px solid var(--border); cursor: pointer; transition: transform 0.1s;
    }
    .recent-item:active { transform: scale(0.98); }
    .recent-item img { width: 44px; height: 44px; object-fit: cover; border-radius: 8px; }
    .back-btn { background: transparent; color: var(--text-secondary); padding: 8px 0; margin-bottom: 16px; }
    .multiselect-wrap { position: relative; }
    .multiselect-trigger {
      display: flex; align-items: center; flex-wrap: wrap; gap: 6px; min-height: 44px;
      padding: 10px 12px; background: var(--bg-secondary); border: 1px solid var(--border);
      border-radius: 8px; cursor: pointer; font-size: 0.9rem;
    }
    .multiselect-trigger:focus { outline: none; border-color: var(--accent); }
    .multiselect-trigger.open { border-color: var(--accent); }
    .multiselect-placeholder { color: var(--text-secondary); }
    .multiselect-chip { background: var(--bg-card); padding: 4px 8px; border-radius: 6px; font-size: 0.8rem; }
    .multiselect-panel {
      display: none; position: absolute; top: 100%; left: 0; right: 0; margin-top: 4px;
      max-height: 200px; overflow-y: auto; background: var(--bg-card);
      border: 1px solid var(--border); border-radius: 8px; z-index: 100;
    }
    .multiselect-wrap.open .multiselect-panel { display: block; }
    .multiselect-option {
      padding: 10px 12px; cursor: pointer; border-bottom: 1px solid var(--border);
    }
    .multiselect-option:last-child { border-bottom: none; }
    .multiselect-option:hover, .multiselect-option.selected { background: rgba(233,69,96,0.2); }
    @media (min-width: 480px) {
      .modal { border-radius: 24px; margin: auto 16px 16px; }
    }
  </style>
</head>
<body>
  <!-- v:2025-02-15-3 -->
  <div class="container">
    <header id="mainHeader">
      <h1>Желай, как никогда прежде</h1>
    </header>

    <div id="content">
      <div class="main-buttons">
        <button class="btn" data-nav="manageWishlists" onclick="window.__nav&&window.__nav('manageWishlists')">Вишлисты</button>
        <button class="btn btn-secondary" data-nav="manageCategories" onclick="window.__nav&&window.__nav('manageCategories')">Категории</button>
        <button class="btn btn-secondary" data-nav="manageWishes" onclick="window.__nav&&window.__nav('manageWishes')">Желания</button>
      </div>
      <h3 class="section-title">Недавно изменённые</h3>
      <div class="recent-list"><p style="color:var(--text-secondary);font-size:0.9rem;">Нет вишлистов</p></div>
    </div>
  </div>

  <!-- Wish modal -->
  <div class="modal-overlay" id="wishModal">
    <div class="modal">
      <h2 id="wishModalTitle">Добавить желание</h2>
      <form id="wishForm">
        <input type="hidden" id="wishId">
        <div class="form-group">
          <label><span class="required">*</span> Изображение</label>
          <div class="img-upload" id="imgUpload">
            <input type="file" id="wishImage" accept="image/*" capture="environment">
            <span id="imgUploadText">Нажми или перетащи фото</span>
            <img id="imgPreview" class="img-preview" style="display:none;" alt="">
          </div>
          <div id="imgError" class="error-msg" style="display:none;"></div>
        </div>
        <div class="form-group">
          <label><span class="required">*</span> Название <span id="nameCounter">0/100</span></label>
          <input type="text" id="wishName" maxlength="100" placeholder="Название желания">
          <div id="nameError" class="error-msg" style="display:none;"></div>
        </div>
        <div class="form-row">
          <div class="form-group">
            <label>Стоимость</label>
            <input type="number" id="wishPrice" min="1" max="9999999" placeholder="0">
            <div id="priceError" class="error-msg" style="display:none;"></div>
          </div>
          <div class="form-group">
            <label>Валюта</label>
            <select id="wishCurrency">
              <option value="">—</option>
              <option value="€">€</option>
              <option value="$">$</option>
              <option value="Br">Br</option>
              <option value="₽">₽</option>
              <option value="₸">₸</option>
            </select>
          </div>
        </div>
        <div class="form-group">
          <label>Размер</label>
          <input type="text" id="wishSize" placeholder="M, 42, XL">
          <div id="sizeError" class="error-msg" style="display:none;"></div>
        </div>
        <div class="form-group">
          <label>Ссылка на продукт</label>
          <input type="url" id="wishLink" placeholder="https://...">
          <div id="linkError" class="error-msg" style="display:none;"></div>
        </div>
        <div class="form-group">
          <label>Комментарий <span id="commentCounter">0/500</span></label>
          <textarea id="wishComment" maxlength="500" placeholder="Дополнительные заметки"></textarea>
        </div>
        <div class="form-group">
          <label>Категория</label>
          <select id="wishCategory">
            <option value="">Без категории</option>
          </select>
        </div>
        <div class="form-group">
          <label>Вишлисты</label>
          <div class="multiselect-wrap" id="wishWishlistSelect"></div>
          <small style="color:var(--text-secondary);font-size:0.8rem;">Выберите вишлисты из списка</small>
        </div>
        <div class="form-actions">
          <button type="button" class="btn btn-secondary" id="wishCancel">Отмена</button>
          <button type="submit" class="btn">Сохранить</button>
        </div>
      </form>
    </div>
  </div>

  <!-- Categories modal -->
  <div class="modal-overlay" id="catsModal">
    <div class="modal">
      <h2>Править категории</h2>
      <p style="color:var(--text-secondary);font-size:0.9rem;margin-bottom:16px;">
        Удаляй ненужные и добавляй свои. Без категорий приложение тоже работает.
      </p>
      <div class="cat-list" id="catList"></div>
      <div class="cat-add">
        <input type="text" id="newCatName" placeholder="Название категории">
        <button type="button" class="btn" id="addCatBtn">Добавить</button>
      </div>
      <div class="form-actions" style="margin-top:20px;">
        <button type="button" class="btn btn-secondary" id="catsClose">Закрыть</button>
      </div>
    </div>
  </div>

  <!-- Wishlists modal -->
  <div class="modal-overlay" id="wlModal">
    <div class="modal">
      <h2>Править вишлисты</h2>
      <p style="color:var(--text-secondary);font-size:0.9rem;margin-bottom:16px;">
        Вишлист — папка для карточек желаний. Добавляй, удаляй, переноси карточки.
      </p>
      <div class="cat-list" id="wlList"></div>
      <div style="margin-top:16px;" id="wlAddForm">
        <div class="form-group">
          <label><span class="required">*</span> Название</label>
          <input type="text" id="newWlName" placeholder="Название вишлиста">
        </div>
        <div class="form-group">
          <label>Приватность</label>
          <select id="newWlPrivacy">
            <option value="private">Приватный — только вы</option>
            <option value="public">Публичный — любой по ссылке может смотреть и бронировать</option>
            <option value="shared">Совместный — соавторы по приглашению</option>
          </select>
        </div>
        <div class="form-group">
          <label>Картинка</label>
          <div class="img-upload wl-add-img" id="wlImgUpload">
            <input type="file" id="wlImage" accept="image/*">
            <span id="wlImgText">Добавить обложку (необязательно)</span>
            <img id="wlImgPreview" class="img-preview" style="display:none;max-height:120px;" alt="">
          </div>
        </div>
        <button type="button" class="btn" id="addWlBtn">Добавить вишлист</button>
      </div>
      <div id="wlEditForm" style="display:none;">
        <div class="form-group">
          <label><span class="required">*</span> Название</label>
          <input type="text" id="editWlName" placeholder="Название вишлиста">
        </div>
        <div class="form-group">
          <label>Приватность</label>
          <select id="editWlPrivacy">
            <option value="private">Приватный</option>
            <option value="public">Публичный</option>
            <option value="shared">Совместный</option>
          </select>
        </div>
        <div class="form-group">
          <label>Картинка</label>
          <div class="img-upload wl-add-img" id="wlImgUploadEdit">
            <input type="file" id="wlImageEdit" accept="image/*">
            <span id="wlImgTextEdit">Обложка</span>
            <img id="wlImgPreviewEdit" class="img-preview" style="display:none;max-height:120px;" alt="">
          </div>
        </div>
        <div id="wlEditFormExtras"></div>
        <div class="form-actions">
          <button type="button" class="btn btn-secondary" id="editWlCancel">Отмена</button>
          <button type="button" class="btn" id="editWlSave">Сохранить</button>
        </div>
      </div>
      <div class="form-actions" style="margin-top:20px;">
        <button type="button" class="btn btn-secondary" id="wlClose">Закрыть</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="shareWlModal">
    <div class="modal">
      <h2>Поделиться вишлистом</h2>
      <p style="color:var(--text-secondary);font-size:0.9rem;margin-bottom:12px;">Отправь ссылку в Telegram — она откроется в боте. Кто угодно по ссылке увидит вишлист и сможет забронировать карточки.</p>
      <div class="share-link" id="shareWlLink" style="word-break:break-all;padding:12px;background:var(--bg-card);border-radius:8px;font-size:0.85rem;"></div>
      <p id="shareWlHint" style="display:none;color:var(--accent);font-size:0.8rem;margin-top:8px;">Чтобы ссылка открывалась в боте, укажи <code>wantthat_bot</code> и <code>wantthat</code> в начале скрипта.</p>
      <div class="form-actions" style="margin-top:16px;">
        <button type="button" class="btn btn-secondary" id="shareWlClose">Закрыть</button>
        <button type="button" class="btn" id="shareWlCopy">Копировать</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="shareWelcomeModal">
    <div class="modal">
      <h2>Поделились с вами</h2>
      <p id="shareWelcomeText" style="color:var(--text-secondary);font-size:0.95rem;margin-bottom:20px;"></p>
      <button type="button" class="btn" id="shareWelcomeOk">Понял</button>
    </div>
  </div>

  <div class="modal-overlay" id="inviteConsentModal">
    <div class="modal">
      <h2>Приглашение</h2>
      <p id="inviteConsentText" style="color:var(--text-secondary);font-size:0.95rem;margin-bottom:20px;"></p>
      <div class="form-actions">
        <button type="button" class="btn btn-secondary" id="inviteConsentDecline">Отказаться</button>
        <button type="button" class="btn" id="inviteConsentAccept">Принять</button>
      </div>
    </div>
  </div>

  <div class="modal-overlay" id="inviteWlModal">
    <div class="modal">
      <h2>Пригласить соавтора</h2>
      <p style="color:var(--text-secondary);font-size:0.9rem;margin-bottom:12px;">Отправь ссылку в Telegram — она откроется в боте, человек станет соавтором и сможет редактировать вишлист.</p>
      <div class="share-link" id="inviteWlLink" style="word-break:break-all;padding:12px;background:var(--bg-card);border-radius:8px;font-size:0.85rem;"></div>
      <p id="inviteWlHint" style="display:none;color:var(--accent);font-size:0.8rem;margin-top:8px;">Чтобы ссылка открывалась в боте, укажи <code>TELEGRAM_BOT</code> и <code>TELEGRAM_APP</code> в начале скрипта.</p>
      <div class="form-actions" style="margin-top:16px;">
        <button type="button" class="btn btn-secondary" id="inviteWlClose">Закрыть</button>
        <button type="button" class="btn" id="inviteWlCopy">Копировать</button>
      </div>
    </div>
  </div>

  <script>
    // --- Supabase: вставь свои данные из Project Settings → API ---
    const SUPABASE_URL = 'https://ieounwqtaxpozwdgbwpn.supabase.co';
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imllb3Vud3F0YXhwb3p3ZGdid3BuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzExMjI5ODgsImV4cCI6MjA4NjY5ODk4OH0.axb4HUzkz-VZ2pJZOR08gY-q4Na3U1gcxbK2eLtZRcg';
    let sb = null;
    try {
      if (SUPABASE_URL && SUPABASE_ANON_KEY && window.supabase) {
        sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: false }
        });
      }
    } catch (_) {}
    const useSupabase = !!sb;

    // --- Telegram Bot: для ссылок «Поделиться» / «Пригласить» — чтобы открывались в боте ---
    // Укажи username бота (без @) и short_name Mini App из BotFather
    const TELEGRAM_BOT = 'wantthat_bot';
    const TELEGRAM_APP = 'wantthat';
    // API ключи для анализа изображений (выбери один вариант):
    // ВАРИАНТ 1: Tesseract.js (БЕСПЛАТНО, работает в браузере, доступен в Беларуси!)
    // Не требует ключа - работает сразу! Рекомендуется для Беларуси/России.
    
    // ВАРИАНТ 2: Google Gemini (БЕСПЛАТНО до 15 запросов/мин, может быть заблокирован)
    const GEMINI_API_KEY = 'AIzaSyCi_FCso6btBPX-p_qZZ69lu78age4P-ww'; // Gemini API — запасной Vision
    // sessionStorage.setItem('gemini_key', '...')
    
    // ВАРИАНТ 3: OCRAPI.cloud (БЕСПЛАТНО 250 запросов/месяц)
    const OCRAPI_KEY = ''; // Получи на https://ocr.space/ocrapi
    // sessionStorage.setItem('ocrapi_key', '...')
    
    // ВАРИАНТ 4: OpenAI (платный, ~$0.01-0.03 за изображение)
    const OPENAI_API_KEY = ''; // sessionStorage.setItem('openai_key', '...')
    
    // Токен Telegram бота для получения файлов (опционально, если бот передает URL напрямую - не нужен)
    // sessionStorage.setItem('bot_token', 'YOUR_BOT_TOKEN');
    
    // Какой API использовать (по умолчанию пробует бесплатные сначала, Tesseract работает везде!)
    const CV_API_PRIORITY = ['gemini', 'tesseract', 'ocrapi', 'openai']; // Gemini первым — умный Vision для Insta/сложных скринов
    
    // ИНСТРУКЦИЯ ДЛЯ БОТА:
    // Когда пользователь отправляет изображение в бота, бот должен:
    // 1. Получить file_id или file_path изображения
    // 2. Открыть Mini App с start_param:
    //    - Вариант 1: img_url_<encoded_url> - где encoded_url это URL изображения (encodeURIComponent)
    //    - Вариант 2: img_<file_id> - если используется bot_token для получения файла
    // Пример: bot.openWebApp({ url: 'https://your-app.netlify.app', start_param: 'img_url_' + encodeURIComponent(imageUrl) })
    // Мини-приложение автоматически проанализирует изображение и откроет форму с автозаполнением

    const tg = window.Telegram?.WebApp;
    const _savedStartParam = (() => {
      const h = window.location.hash.slice(1);
      if (h) { try { const p = new URLSearchParams(h); const sp = p.get('tgWebAppStartParam'); if (sp) return sp; } catch (_) {} }
      return tg?.initDataUnsafe?.start_param || '';
    })();
    const WISHES_KEY = 'wishlist_wishes';
    const CATS_KEY = 'wishlist_categories';
    const WISHLISTS_KEY = 'wishlist_folders';
    const DEFAULT_CATS = ['день рождения', 'новый год', 'без повода', 'разное'];
    const PRIVACY_VALUES = ['private', 'public', 'shared'];
    const NAME_RE = /^[a-zA-Zа-яА-ЯёЁ0-9\s\-_.,!?()]*$/;
    const SIZE_RE = /^[a-zA-Z0-9\s\-.]*$/;
    const URL_RE = /^(https?:\/\/)?([\w-]+\.)+[\w-]+(\/[\w\-./?%&=]*)?$/i;

    // Функция проверки несохраненных данных
    function hasUnsavedData() {
      // Проверяем, открыта ли модалка формы желания
      const wishModal = document.getElementById('wishModal');
      if (wishModal && wishModal.classList.contains('open')) {
        const form = document.getElementById('wishForm');
        const name = document.getElementById('wishName')?.value?.trim();
        const comment = document.getElementById('wishComment')?.value?.trim();
        const link = document.getElementById('wishLink')?.value?.trim();
        const price = document.getElementById('wishPrice')?.value?.trim();
        const size = document.getElementById('wishSize')?.value?.trim();
        const wishlistId = document.getElementById('wishWishlist')?.value;
        
        // Если есть хотя бы одно заполненное поле или изображение - есть несохраненные данные
        if (name || comment || link || price || size || wishlistId || pendingImageBase64) {
          return true;
        }
      }
      
      // Проверяем другие модалки с несохраненными данными
      // (можно добавить проверку для других форм)
      
      return false;
    }
    
    // Функция обновления состояния предупреждения о закрытии
    function updateClosingConfirmation() {
      if (tg && typeof tg.enableClosingConfirmation === 'function' && typeof tg.disableClosingConfirmation === 'function') {
        if (hasUnsavedData()) {
          tg.enableClosingConfirmation();
        } else {
          tg.disableClosingConfirmation();
        }
      }
    }

    try {
      if (tg) {
        tg.ready();
        tg.expand();
        // Не включаем предупреждение сразу - будем включать только при наличии несохраненных данных
        updateClosingConfirmation();
        document.body.style.background = tg.themeParams?.bg_color || 'var(--bg-primary)';
        if (tg.themeParams?.text_color) document.body.style.color = tg.themeParams.text_color;
        if (tg.themeParams?.secondary_bg_color) document.documentElement.style.setProperty('--bg-secondary', tg.themeParams.secondary_bg_color);
        document.body.classList.toggle('light', tg.colorScheme === 'light');
        tg.setHeaderColor(tg.themeParams?.bg_color || '#1a1a2e');
      }
    } catch (_) {}

    const CLIENT_ID_KEY = 'wishlist_client_id';
    function packPayload(obj) {
      const s = JSON.stringify(obj);
      if (typeof LZString !== 'undefined') return LZString.compressToEncodedURIComponent(s);
      return btoa(unescape(encodeURIComponent(s)));
    }
    function unpackPayload(str) {
      if (!str) return null;
      try {
        if (typeof LZString !== 'undefined') {
          const d = LZString.decompressFromEncodedURIComponent(str);
          if (d) return JSON.parse(d);
        }
        return JSON.parse(decodeURIComponent(escape(atob(str))));
      } catch (_) { return null; }
    }
    let _memStorage = {};
    let _anonClientId = null;
    function safeGetItem(key) {
      if (useSupabase && key !== CLIENT_ID_KEY) return null;
      try { return localStorage.getItem(key); } catch (_) { return _memStorage[key] ?? null; }
    }
    function safeSetItem(key, val) {
      if (useSupabase && key !== CLIENT_ID_KEY) return;
      try { localStorage.setItem(key, val); } catch (_) { _memStorage[key] = val; }
    }
    function getCurrentUserId() {
      const u = tg?.initDataUnsafe?.user;
      if (u?.id) return 'tg_' + u.id;
      if (useSupabase) {
        if (!_anonClientId) _anonClientId = 'anon_' + Date.now() + '_' + Math.random().toString(36).slice(2);
        return _anonClientId;
      }
      let cid = safeGetItem(CLIENT_ID_KEY);
      if (!cid) { cid = 'anon_' + Date.now() + '_' + Math.random().toString(36).slice(2); safeSetItem(CLIENT_ID_KEY, cid); }
      return cid;
    }
    let currentUserId;
    try { currentUserId = getCurrentUserId(); } catch (_) { currentUserId = 'anon_' + Date.now(); }

    let wishes = [];
    let categories = [...DEFAULT_CATS];
    let wishlists = [];
    let pendingImageBase64 = null;
    let pendingWlImageBase64 = null;
    let publicViewData = null;
    let pendingInviteData = null;
    let shareWelcomeShown = false;
    let editingWlId = null;
    let currentView = 'main';
    let selectedWlId = null;

    function migrateWish(w) {
      const ids = Array.isArray(w.wishlistIds) ? w.wishlistIds : (w.wishlistId ? [w.wishlistId] : []);
      const { wishlistId, ...rest } = w;
      return { ...rest, wishlistIds: ids };
    }

    async function ensureUser() {
      const u = tg?.initDataUnsafe?.user;
      if (!u?.id || !useSupabase) return { error: null };
      const { error } = await sb.from('users').upsert({ id: 'tg_' + u.id, first_name: u.first_name, username: u.username }, { onConflict: 'id' });
      return { error };
    }

    async function getImageFromTelegram(fileId) {
      try {
        const botToken = sessionStorage.getItem('bot_token');
        if (!botToken) {
          tg?.showAlert?.('Токен бота не найден. Обратитесь к администратору.');
          return null;
        }
        const response = await fetch(`https://api.telegram.org/bot${botToken}/getFile?file_id=${fileId}`);
        const data = await response.json();
        if (!data.ok || !data.result?.file_path) return null;
        return `https://api.telegram.org/file/bot${botToken}/${data.result.file_path}`;
      } catch (e) {
        console.error('Error getting image from Telegram:', e);
        return null;
      }
    }
    
    function decodeImageUrl(encoded) {
      try {
        return decodeURIComponent(encoded);
      } catch {
        return null;
      }
    }

    async function analyzeImageWithTesseract(imageUrl) {
      if (typeof Tesseract === 'undefined') {
        console.error('Tesseract.js not loaded');
        return null;
      }
      try {
        console.log('Начинаю анализ через Tesseract...');
        let imageData;
        if (imageUrl.startsWith('data:')) {
          imageData = imageUrl;
        } else {
          const response = await fetch(imageUrl);
          const blob = await response.blob();
          imageData = await new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
          });
        }
        
        // Worker + recognize с blocks для bbox (название обычно крупнее)
        const worker = await Tesseract.createWorker('rus+eng', 1, {
          logger: (m) => {
            if (m.status === 'recognizing text') {
              console.log(`Tesseract прогресс: ${Math.round(m.progress * 100)}%`);
            }
          }
        });
        const { data } = await worker.recognize(imageData, {}, { text: true, blocks: true });
        await worker.terminate();
        const text = data?.text || '';
        if (!text || text.trim().length < 5) return null;

        // Собираем строки с bbox (1), позицией y0 (5), порядком появления index (2)
        const linesWithBbox = [];
        let lineIndex = 0;
        const pushLine = (line) => {
          const t = (line.text || '').trim();
          if (!t) return;
          const b = line.bbox || { x0: 0, y0: 0, x1: 0, y1: 0 };
          const h = (b.y1 || 0) - (b.y0 || 0);
          const w = (b.x1 || 0) - (b.x0 || 0);
          linesWithBbox.push({ text: t, area: w * h, height: h, y0: b.y0 ?? 0, index: lineIndex++ });
        };
        if (data?.blocks) {
          for (const block of data.blocks) {
            if (block.paragraphs) {
              for (const par of block.paragraphs) {
                if (par.lines) for (const line of par.lines) pushLine(line);
              }
            } else if (block.lines) {
              for (const line of block.lines) pushLine(line);
            }
          }
        }
        const lines = linesWithBbox.length ? linesWithBbox.map(l => l.text) : text.split('\n').map(l => l.trim()).filter(l => l.length > 0);
        let name = null;
        let price = null;
        let currency = null;
        let size = null;
        const fullText = text.toLowerCase();
        
        // Вариант 4: стоп-слова признаков (степень помола, регулируемая и т.п.) — не название
        const FEATURE_STOP_WORDS = ['степень', 'степени', 'степенью', 'помола', 'помол', 'помолу', 'регулируемая', 'регулируемый', 'регулировка', 'металлический', 'стильный', 'дизайн', 'материал', 'режим', 'функция', 'параметр', 'характеристика', 'цвет', 'оттенок', 'высокое', 'качество', 'премиум'];
        const isOnlyFeatures = (line) => {
          const words = line.toLowerCase().split(/\s+/).filter(w => w.length >= 2);
          if (words.length === 0) return true;
          return words.every(w => FEATURE_STOP_WORDS.includes(w));
        };

        const isBadName = (line) => {
          const lineLower = line.toLowerCase();
          if (isOnlyFeatures(line)) return true;
          if (/[|<>\\\/]/.test(line)) return true; // мусор OCR: | < > \ /
          const skipKeywords = ['цена', 'price', 'стоимость', 'cost', 'размер', 'size', 'руб', 'рублей', 'бел', 'byn', 'usd', 'eur', 'шт', 'шт.', 'осталось', 'до конца', 'единиц', 'единицы', 'акция', 'скидка', 'распродажа', 'промо', 'спецпредложение', 'только сегодня', 'главная', 'каталог', 'избранное', 'корзина', 'ozon', 'wildberries', 'яндекс маркет', 'мой ozon', 'мой wb'];
          if (skipKeywords.some(k => lineLower.includes(k))) return true;
          if ((line.match(/[—–−]/g) || []).length >= 2 || /~~/.test(line)) return true; // хлебные крошки: "А — Б — В" или "А ~~ Б"
          if (/^\d+[\s,\.]?\d*$/.test(line)) return true; // только цифры
          if (/^\d{1,2}:\d{2}/.test(line)) return true; // время 15:52
          if (/[@+]\s*[a-z0-9]/i.test(line) || line.includes('@')) return true; // контакты
          // Символы-мусор OCR: ©®™℠ ±×÷°¬∞≠≤≥ ¢£¤ «»‹›‚„""'' •◦… §¶†‡№⁄℅ ←→↑↓⇒↔ псевдографика U+2500–257F
          if (/[\u00A9\u00AE\u2122\u2120|<>\\\/!@#$%^&*+=\[\]{}®©™℠±×÷°¬∞≠≤≥¢£¤«»‹›‚„"''•◦…§¶†‡№⁄℅←→↑↓⇒↔\u2500-\u257F´`¨˚˜˝˘ˇ˙¸˛]/.test(line)) return true;
          if (/^[=\-_]/.test(line) || /^[=\-_\s]+/.test(line) || /^[=\-_]+[a-zа-яё]*$/i.test(line)) return true; // "- =вы"
          if (/^[€$₽Br₸\s\d,\.]+$/.test(lineLower)) return true;
          if (line.length < 5 || line.length > 80) return true;
          if (/^[\d\s:.,]+$/.test(line)) return true; // только цифры/время
          const letters = (line.match(/[a-zA-Zа-яА-ЯёЁ]/g) || []).length;
          const total = (line.match(/[a-zA-Zа-яА-ЯёЁ0-9]/g) || []).length;
          if (letters < 3) return true; // слишком мало букв
          if (total > 0 && letters / total < 0.7) return true; // доля букв < 70% — мусор
          return false;
        };
        
        // Приоритет существительным: прилагательные часто оканчиваются на -ая, -ый, -ое, -ий и т.д.
        const looksLikeAdjective = (line) => /[а-яё](ая|ый|ое|ий|яя|ее|ой|ие|ые|ую|ую)$/i.test(line.trim());
        
        // Сначала ищем цену рядом с валютой (BYN, Br, ₽ и т.д.) — приоритет
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const lineLower = line.toLowerCase();
          if (!price && lineLower.match(/byn|br|₽|руб|usd|\$|eur|€|₸/)) {
            const priceWithCurrency = line.match(/([0-9\s]+[,\.][0-9]{2})\s*(?:byn|br|₽|руб|usd|\$|eur|€|₸)/i)
              || line.match(/([0-9]{2,7}[,\.][0-9]{0,2})/);
            if (priceWithCurrency) {
              const priceStr = priceWithCurrency[1].replace(/\s/g, '').replace(',', '.');
              const priceNum = parseFloat(priceStr);
              if (priceNum >= 0.01 && priceNum <= 9999999) {
                price = Math.round(priceNum * 100) / 100;
                if (lineLower.includes('byn') || lineLower.includes('br')) currency = 'Br';
                else if (lineLower.includes('руб') || lineLower.includes('₽') || lineLower.includes('бел')) currency = '₽';
                else if (lineLower.includes('usd') || line.includes('$')) currency = '$';
                else if (lineLower.includes('eur') || line.includes('€')) currency = '€';
                else if (lineLower.includes('₸')) currency = '₸';
              }
            }
          }
        }
        
        // Варианты 1+2+5: bbox (крупнее), позиция (y0 — выше), порядок (раньше)
        const candidates = linesWithBbox.length
          ? [...linesWithBbox].sort((a, b) => {
              const da = (b.area || 0) - (a.area || 0);
              if (da !== 0) return da;
              const dy = (a.y0 ?? 9999) - (b.y0 ?? 9999); // меньше y0 = выше в кадре
              if (dy !== 0) return dy;
              return (a.index ?? 0) - (b.index ?? 0); // раньше в потоке текста
            })
          : lines.map((t, i) => ({ text: t, area: 0, y0: i * 20, index: i }));
        for (let i = 0; i < candidates.length && !name; i++) {
          const line = candidates[i].text || candidates[i];
          const trimmed = String(line).trim();
          if (!isBadName(trimmed) && !looksLikeAdjective(trimmed)) name = trimmed;
        }
        if (!name) {
          for (let i = 0; i < candidates.length && !name; i++) {
            const line = candidates[i].text || candidates[i];
            const trimmed = String(line).trim();
            if (!isBadName(trimmed)) name = trimmed;
          }
        }

        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          const lineLower = line.toLowerCase();
          if (!price) {
            const priceWithLabel = line.match(/(?:цена|price|стоимость|cost)[\s:]*([0-9\s,\.]+)/i);
            const priceOnly = line.match(/([0-9]{2,7}[,\.][0-9]{0,2}|[0-9]{2,7})/);
            const priceMatch = priceWithLabel || priceOnly;
            if (priceMatch) {
              const priceStr = priceMatch[1].replace(/\s/g, '').replace(',', '.');
              const priceNum = parseFloat(priceStr);
              if (priceNum >= 10 && priceNum <= 9999999) {
                price = priceNum % 1 ? Math.round(priceNum * 100) / 100 : priceNum;
              }
            }
          }
          if (!currency) {
            const currencyMatch = line.match(/([€$₽Br₸])/) || (lineLower.match(/byn|br/i) ? 'Br' : null) || (lineLower.match(/руб|бел|byr/i) ? '₽' : null) || (lineLower.match(/usd|долл/i) ? '$' : null) || (lineLower.match(/eur|евр/i) ? '€' : null);
            if (currencyMatch) {
              currency = typeof currencyMatch === 'string' ? currencyMatch : currencyMatch[1];
            }
          }
          // Размер: только текстовый XXS-XL или числовой — только при распознанной обуви
          const footwearKeywords = /обувь|кроссовки|туфли|ботинки|сапоги|размер обуви|shoe|boot|sneaker/i;
          const textSizeMatch = line.match(/\b(xxs|xxxs|xs|s|m|l|xl|xxl|xxxl|2xl|3xl)\b/i);
          if (textSizeMatch && !size) {
            size = textSizeMatch[1].toUpperCase();
          }
          if (!size && footwearKeywords.test(fullText)) {
            const sizeWithLabel = line.match(/(?:размер|size)[\s:]*(\d{2,3})/i);
            if (sizeWithLabel && parseInt(sizeWithLabel[1]) >= 20 && parseInt(sizeWithLabel[1]) <= 50) {
              size = sizeWithLabel[1];
            }
          }
        }
        if (!name && lines.length > 0) {
          // Пробуем существительные (не прилагательные)
          for (const ln of lines) {
            if (!isBadName(ln) && !looksLikeAdjective(ln.trim())) {
              name = ln.trim();
              break;
            }
          }
          // Если не нашли — берём любое подходящее (в т.ч. прилагательное)
          if (!name) {
            for (const ln of lines) {
              if (!isBadName(ln)) {
                name = ln.trim();
                break;
              }
            }
          }
        }
        return { name, price, currency, size };
      } catch (e) {
        console.error('Error analyzing with Tesseract:', e);
        return null;
      }
    }

    async function analyzeImageWithGemini(imageUrl) {
      const apiKey = GEMINI_API_KEY || sessionStorage.getItem('gemini_key');
      if (!apiKey) return null;
      try {
        const imageBase64 = imageUrl.startsWith('data:') ? imageUrl.split(',')[1] : await fetch(imageUrl).then(r => r.blob()).then(blob => new Promise((resolve) => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result.split(',')[1]);
          reader.readAsDataURL(blob);
        }));
        const mimeType = imageUrl.startsWith('data:') ? imageUrl.match(/data:([^;]+)/)?.[1] || 'image/jpeg' : 'image/jpeg';
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent?key=${apiKey}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            contents: [{
              parts: [
                {
                  text: `Проанализируй это изображение товара и извлеки информацию в формате JSON:
{
  "name": "название товара (точное название продукта)",
  "price": число (только цифры, запятая/точка как десятичный разделитель),
  "currency": "символ валюты (€, $, ₽, Br, ₸) или null если не найдено",
  "size": "размер (M, L, XL, 42, 43, S, XXL и т.д.) или null если не найдено"
}

Важно:
- name: осмысленное название товара из описания/подписи поста. Приоритет СУЩЕСТВИТЕЛЬНЫМ (платье, кофемолка, помада), а не прилагательным (коричневое, регулируемая). НЕ мусор OCR ("Л М re i"). НЕ навигация, хлебные крошки. Минимум 2 слова или одно длинное существительное. Без спецсимволов | < > ® ©. Для Insta — из caption под фото.
- price: ОБЯЗАТЕЛЬНО число рядом с валютой. НЕ бери время (1:30), количество (1 шт). Только сумма. Примеры: "113,94 BYN" → 113.94.
- currency (связка число + валюта рядом):
  BYN, Br, бун → "Br"
  руб., рублей, рубл., ₽, бел → "₽"
  долл., долларов, usd, $ → "$"
  евро, eur, € → "€"
  тенге, ₸, тг → "₸"
- size: размер одежды/обуви, если указан

Если цену с валютой не видишь — price: null. Отвечай ТОЛЬКО валидным JSON.`
                },
                {
                  inlineData: {
                    mimeType: mimeType,
                    data: imageBase64
                  }
                }
              ]
            }]
          })
        });
        const data = await response.json();
        const text = data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!text) return null;
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (!jsonMatch) return null;
        return JSON.parse(jsonMatch[0]);
      } catch (e) {
        console.error('Error analyzing with Gemini:', e);
        return null;
      }
    }

    async function analyzeImageWithOCRAPI(imageUrl) {
      const apiKey = OCRAPI_KEY || sessionStorage.getItem('ocrapi_key');
      if (!apiKey) return null;
      try {
        const formData = new FormData();
        if (imageUrl.startsWith('data:')) {
          const blob = await fetch(imageUrl).then(r => r.blob());
          formData.append('file', blob, 'image.jpg');
        } else {
          const response = await fetch(imageUrl);
          const blob = await response.blob();
          formData.append('file', blob, 'image.jpg');
        }
        formData.append('language', 'rus+eng');
        formData.append('isOverlayRequired', 'false');
        const ocrResponse = await fetch('https://api.ocr.space/parse/image', {
          method: 'POST',
          headers: { 'apikey': apiKey },
          body: formData
        });
        const ocrData = await ocrResponse.json();
        const extractedText = ocrData.ParsedResults?.[0]?.ParsedText || '';
        if (!extractedText) return null;
        const nameMatch = extractedText.match(/(?:название|name|товар|product)[\s:]*([^\n\r]+)/i);
        const priceMatch = extractedText.match(/(?:цена|price|стоимость)[\s:]*([0-9\s,\.]+)/i);
        const currencyMatch = extractedText.match(/([€$₽Br₸])/);
        const sizeMatch = extractedText.match(/(?:размер|size)[\s:]*([MXLS\d]+)/i);
        return {
          name: nameMatch ? nameMatch[1].trim() : null,
          price: priceMatch ? parseInt(priceMatch[1].replace(/\s/g, '').replace(',', '.')) : null,
          currency: currencyMatch ? currencyMatch[1] : null,
          size: sizeMatch ? sizeMatch[1].trim() : null
        };
      } catch (e) {
        console.error('Error analyzing with OCRAPI:', e);
        return null;
      }
    }

    async function analyzeImageWithOpenAI(imageUrl) {
      const apiKey = OPENAI_API_KEY || sessionStorage.getItem('openai_key');
      if (!apiKey) return null;
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${apiKey}`
          },
          body: JSON.stringify({
            model: 'gpt-4o',
            messages: [{
              role: 'user',
              content: [
                {
                  type: 'text',
                  text: `Проанализируй это изображение товара и извлеки информацию в формате JSON:
{
  "name": "название товара (точное название продукта)",
  "price": число (только цифры, без валюты и пробелов),
  "currency": "символ валюты (€, $, ₽, Br, ₸) или null если не найдено",
  "size": "размер (M, L, XL, 42, 43, S, XXL и т.д.) или null если не найдено"
}

Важно:
- name: точное название товара с изображения
- price: только число (например, 1299, не "1 299" или "1,299")
- currency: только символ валюты, если виден на изображении
- size: размер одежды/обуви, если указан

Если параметра нет на изображении, верни null для него.
Отвечай ТОЛЬКО валидным JSON, без дополнительного текста или объяснений.`
                },
                {
                  type: 'image_url',
                  image_url: { url: imageUrl }
                }
              ]
            }],
            max_tokens: 300
          })
        });
        const data = await response.json();
        if (!data.choices?.[0]?.message?.content) return null;
        const content = data.choices[0].message.content.trim();
        const jsonMatch = content.match(/\{[\s\S]*\}/);
        if (!jsonMatch) return null;
        return JSON.parse(jsonMatch[0]);
      } catch (e) {
        console.error('Error analyzing with OpenAI:', e);
        return null;
      }
    }

    // Функция для безопасного показа alert (с обработкой ошибки "popup already opened")
    function safeShowAlert(message) {
      try {
        tg?.showAlert?.(message);
      } catch (e) {
        // Игнорируем ошибку если popup уже открыт, просто логируем
        console.log(`Не удалось показать alert (popup уже открыт): ${message}`);
      }
    }

    function isSuspiciousName(name) {
      if (!name || typeof name !== 'string') return false;
      const s = name.toLowerCase().trim();
      const navKeywords = ['главная', 'каталог', 'избранное', 'корзина', 'ozon', 'wildberries', 'яндекс маркет', 'мой ozon', 'мой wb'];
      if (navKeywords.some(k => s.includes(k))) return true;
      if ((name.match(/[—–−]/g) || []).length >= 2 || /~~/.test(name)) return true;
      if (name.length > 60) return true;
      if (name.length < 5) return true;
      // Мусор OCR: "Л М re i" — нет слова из 4+ букв
      const words = s.split(/\s+/).filter(w => /[a-zа-яё]/i.test(w));
      const hasLongWord = words.some(w => w.length >= 4);
      if (!hasLongWord && words.length >= 2) return true; // только короткие "слова" — мусор
      if (/[|<>®©]/.test(name)) return true; // спецсимволы
      return false;
    }

    async function analyzeImageWithCV(imageUrl, timeoutMs = 30000) {
      const priority = CV_API_PRIORITY || ['tesseract', 'gemini', 'ocrapi', 'openai'];
      
      for (const api of priority) {
        let result = null;
        let timeoutId = null;
        let analysisAborted = false;
        
        try {
          console.log(`Пробую анализ через ${api}...`);
          
          // Создаем промис с таймаутом для каждой функции анализа
          let analysisPromise;
          if (api === 'tesseract') {
            analysisPromise = analyzeImageWithTesseract(imageUrl);
          } else if (api === 'gemini') {
            analysisPromise = analyzeImageWithGemini(imageUrl);
          } else if (api === 'openai') {
            analysisPromise = analyzeImageWithOpenAI(imageUrl);
          } else if (api === 'ocrapi') {
            analysisPromise = analyzeImageWithOCRAPI(imageUrl);
          } else {
            continue;
          }
          
          // Создаем промис с таймаутом
          const timeoutPromise = new Promise((_, reject) => {
            timeoutId = setTimeout(() => {
              analysisAborted = true;
              reject(new Error(`Таймаут анализа через ${api} (${timeoutMs/1000} сек)`));
            }, timeoutMs);
          });
          
          // Используем Promise.race для таймаута
          result = await Promise.race([analysisPromise, timeoutPromise]);
          
          // Очищаем таймаут если промис завершился успешно
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          
          // Если анализ был прерван таймаутом, не используем результат
          if (analysisAborted) {
            console.log(`Анализ через ${api} прерван по таймауту`);
            continue;
          }
          
          if (result) {
            if (isSuspiciousName(result?.name)) {
              console.log(`${api}: название подозрительное, пробую следующий API`);
              result = null;
            } else {
              console.log(`✓ Анализ успешен через ${api}`);
              return result;
            }
          }
        } catch (e) {
          // Очищаем таймаут при ошибке
          if (timeoutId) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
          
          const errorMsg = e.message || String(e);
          console.warn(`Ошибка анализа через ${api}:`, errorMsg);
          
          // Показываем ошибку пользователю только если это таймаут
          if (errorMsg.includes('Таймаут')) {
            safeShowAlert(`Таймаут ${api} (${timeoutMs/1000} сек). Пробую следующий API...`);
            // Небольшая задержка чтобы пользователь увидел сообщение
            await new Promise(resolve => setTimeout(resolve, 1000));
          }
          
          // Продолжаем пробовать следующий API
          continue;
        }
      }
      
      // Показываем финальное сообщение об ошибке
      safeShowAlert('Не удалось проанализировать изображение. Попробуй другое фото или проверь настройки API.');
      console.error('Все API анализа изображений не сработали');
      return null;
    }

    async function handleImageFromBot(fileId, imageUrl = null) {
      console.log('handleImageFromBot called:', { fileId, imageUrl });
      
        try {
          // Убеждаемся, что пользователь авторизован (данные уже загружены в loadAll)
          await ensureUser();
        
        // Убеждаемся, что данные загружены (если они были потеряны)
        if (!wishlists || wishlists.length === 0 || !wishes || !categories || categories.length === 0) {
          console.log('Перезагружаем данные...');
          if (useSupabase && sb) {
            const wlRes = await loadWishlistsFromSupabase();
            if (wlRes.data) wishlists = wlRes.data;
            wishes = await loadWishesFromSupabase(new Set(wishlists.map((w) => w.id)));
            wishes = Array.isArray(wishes) ? wishes : [];
            const cats = await loadCategoriesFromSupabase();
            categories = Array.isArray(cats) && cats.length ? cats : [...DEFAULT_CATS];
          } else {
            wishes = loadWishesSync();
            wishes = Array.isArray(wishes) ? wishes : [];
            try { wishlists = (JSON.parse(safeGetItem(WISHLISTS_KEY) || '[]')).map(migrateWishlist); } catch (_) { wishlists = []; }
            wishlists = Array.isArray(wishlists) ? wishlists : [];
            try { const raw = safeGetItem(CATS_KEY); categories = raw ? JSON.parse(raw) : [...DEFAULT_CATS]; } catch (_) { categories = [...DEFAULT_CATS]; }
            categories = Array.isArray(categories) ? categories : [...DEFAULT_CATS];
          }
        }
        
        // Получаем URL изображения
        if (!imageUrl && fileId) {
          imageUrl = await getImageFromTelegram(fileId);
        }
        if (!imageUrl) {
          safeShowAlert('Не удалось получить изображение от бота.');
          currentView = 'main';
          render();
          return;
        }
        
        // CORS: если URL с api.telegram.org — загружаем через наш прокси
        if (imageUrl.startsWith('https://api.telegram.org/')) {
          try {
            const proxyUrl = `/.netlify/functions/image-proxy?url=${encodeURIComponent(imageUrl)}`;
            const proxyRes = await fetch(proxyUrl);
            if (!proxyRes.ok) throw new Error('Proxy failed');
            const data = await proxyRes.json();
            if (data.base64) imageUrl = data.base64;
          } catch (e) {
            console.error('Ошибка прокси изображения:', e);
            safeShowAlert('Не удалось загрузить изображение.');
            currentView = 'main';
            render();
            return;
          }
        }
        
        // Анализируем изображение с таймаутом (30 секунд на каждый API)
        // Не показываем popup во время анализа — он не закрывается автоматически
        let extracted;
        try {
          extracted = await analyzeImageWithCV(imageUrl, 30000);
          
          // Если анализ не дал результата, показываем сообщение
          if (!extracted) {
            safeShowAlert('Не удалось проанализировать изображение. Попробуй другое фото или открой форму вручную.');
            currentView = 'main';
            render();
            return;
          }
        } catch (e) {
          console.error('Ошибка анализа изображения:', e);
          const errorMsg = e.message || String(e);
          if (errorMsg.includes('Таймаут')) {
            safeShowAlert('Анализ занял слишком много времени (>30 сек). Попробуй другое фото или открой форму вручную.');
          } else {
            safeShowAlert('Не удалось проанализировать изображение. Попробуй другое фото или открой форму вручную.');
          }
          currentView = 'main';
          render();
          return;
        }
        
        // Загружаем изображение в base64
        let imageBase64;
        try {
          if (imageUrl.startsWith('data:')) {
            imageBase64 = imageUrl;
          } else {
            imageBase64 = await fetch(imageUrl).then(r => r.blob()).then(blob => new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onloadend = () => resolve(reader.result);
              reader.onerror = reject;
              reader.readAsDataURL(blob);
            }));
          }
        } catch (e) {
          console.error('Ошибка загрузки изображения:', e);
          safeShowAlert('Не удалось загрузить изображение.');
          currentView = 'main';
          render();
          return;
        }
        
        // Открываем форму с данными
        openWishModalFromImage(imageBase64, extracted);
        
      } catch (e) {
        console.error('Критическая ошибка в handleImageFromBot:', e);
        safeShowAlert('Произошла ошибка при обработке изображения. Попробуй еще раз.');
        currentView = 'main';
        render();
      }
    }

    async function loadWishesFromSupabase(wlIdSet) {
      const wlIds = wlIdSet || new Set(wishlists.map((w) => w.id));
      const { data: items } = wlIds.size > 0 ? await sb.from('wishlist_items').select('wishlist_id, wish_id').in('wishlist_id', [...wlIds]) : { data: [] };
      const wishIds = new Set((items || []).map((i) => i.wish_id));
      const { data: ownRows } = await sb.from('wishes').select('*').eq('user_id', currentUserId);
      (ownRows || []).forEach((r) => wishIds.add(r.id));
      if (wishIds.size === 0) return [];
      const { data: rows } = await sb.from('wishes').select('*').in('id', [...wishIds]);
      const byWish = {};
      (items || []).forEach((i) => {
        if (!wlIds.has(i.wishlist_id)) return;
        if (!byWish[i.wish_id]) byWish[i.wish_id] = [];
        byWish[i.wish_id].push(i.wishlist_id);
      });
      return (rows || []).map((r) => ({
        id: r.id, name: r.name, image: r.image, price: r.price, currency: r.currency,
        size: r.size, link: r.link, comment: r.comment, category: r.category,
        wishlistIds: byWish[r.id] || [],
      }));
    }

    async function loadWishlistsFromSupabase() {
      const { data: owned, error: errOwned } = await sb.from('wishlists').select('*').eq('owner_id', currentUserId);
      if (errOwned) return { data: [], error: errOwned };
      const { data: collab } = await sb.from('wishlist_collaborators').select('wishlist_id').eq('user_id', currentUserId);
      const collabIds = (collab || []).map((c) => c.wishlist_id);
      const { data: shared } = collabIds.length ? await sb.from('wishlists').select('*').in('id', collabIds) : { data: [] };
      const byId = {};
      (owned || []).forEach((w) => { byId[w.id] = { ...w, ownerId: w.owner_id, coAuthorIds: [w.owner_id] }; });
      (shared || []).forEach((w) => {
        if (!byId[w.id]) byId[w.id] = { ...w, ownerId: w.owner_id, coAuthorIds: [w.owner_id] };
        if (!byId[w.id].coAuthorIds.includes(currentUserId)) byId[w.id].coAuthorIds.push(currentUserId);
      });
      const { data: allCollab } = Object.keys(byId).length ? await sb.from('wishlist_collaborators').select('wishlist_id, user_id').in('wishlist_id', Object.keys(byId)) : { data: [] };
      allCollab?.forEach((c) => {
        if (byId[c.wishlist_id] && !byId[c.wishlist_id].coAuthorIds.includes(c.user_id)) byId[c.wishlist_id].coAuthorIds.push(c.user_id);
      });
      try {
        const { data: followedRows } = await sb.from('followed_public_wishlists').select('wishlist_id').eq('user_id', currentUserId);
        const followedIds = (followedRows || []).map((r) => r.wishlist_id).filter((id) => !byId[id]);
        if (followedIds.length > 0) {
          const { data: followedWls } = await sb.from('wishlists').select('*').in('id', followedIds).eq('privacy', 'public');
          (followedWls || []).forEach((w) => { byId[w.id] = { ...w, ownerId: w.owner_id, isFollowedPublic: true }; });
        }
      } catch (_) {}
      return { data: Object.values(byId).map(migrateWishlist), error: null };
    }

    async function loadCategoriesFromSupabase() {
      const { data } = await sb.from('categories').select('name').eq('user_id', currentUserId);
      return (data || []).map((r) => r.name);
    }

    async function fetchPublicWishlistFromSupabase(wlId) {
      const { data: wlRow, error: e1 } = await sb.from('wishlists').select('*').eq('id', wlId).eq('privacy', 'public').single();
      if (e1 || !wlRow) return null;
      const wl = { ...wlRow, ownerId: wlRow.owner_id };
      const { data: ownerRow } = await sb.from('users').select('first_name, username').eq('id', wl.owner_id).single();
      const ownerName = ownerRow?.username ? '@' + ownerRow.username : (ownerRow?.first_name || 'Пользователь');
      const { data: items } = await sb.from('wishlist_items').select('wish_id').eq('wishlist_id', wlId);
      const wishIds = (items || []).map((i) => i.wish_id);
      const { data: wishRows } = wishIds.length ? await sb.from('wishes').select('*').in('id', wishIds) : { data: [] };
      const wishes = (wishRows || []).map((r) => ({ ...r, wishlistIds: [wlId] }));
      const { data: resRows } = await sb.from('reservations').select('wish_id, user_id, user_name').in('wish_id', wishIds);
      const reservedCards = {};
      (resRows || []).forEach((r) => { reservedCards[r.wish_id] = { userId: r.user_id, userName: r.user_name || 'Кто-то' }; });
      return { type: 'public', wishlist: wl, wishes, reservedCards, ownerName };
    }

    async function addFollowedPublicWishlist(wlId) {
      if (!useSupabase || !sb || !currentUserId) return;
      try {
        const { data: wl } = await sb.from('wishlists').select('owner_id, privacy').eq('id', wlId).single();
        if (!wl || wl.privacy !== 'public' || wl.owner_id === currentUserId) return;
        await sb.from('followed_public_wishlists').upsert({ user_id: currentUserId, wishlist_id: wlId }, { onConflict: 'user_id,wishlist_id' });
      } catch (_) {}
    }

    async function removeFollowedPublicWishlist(wlId) {
      if (!useSupabase || !sb) return;
      await sb.from('followed_public_wishlists').delete().eq('user_id', currentUserId).eq('wishlist_id', wlId);
      const { data: items } = await sb.from('wishlist_items').select('wish_id').eq('wishlist_id', wlId);
      const wishIds = (items || []).map((i) => i.wish_id);
      if (wishIds.length) await sb.from('reservations').delete().eq('user_id', currentUserId).in('wish_id', wishIds);
    }

    async function fetchInviteWishlistFromSupabase(wlId) {
      const { data: wlRow, error: e1 } = await sb.from('wishlists').select('*').eq('id', wlId).eq('privacy', 'shared').single();
      if (e1 || !wlRow) return null;
      const { data: ownerRow } = await sb.from('users').select('first_name, username').eq('id', wlRow.owner_id).single();
      const ownerName = ownerRow?.username ? '@' + ownerRow.username : (ownerRow?.first_name || 'Пользователь');
      return { wishlist: { ...wlRow, name: wlRow.name }, ownerName };
    }

    function loadWishesSync() {
      const hash = window.location.hash.slice(1);
      if (hash) {
        const data = unpackPayload(hash);
        if (data?.type === 'public') { publicViewData = data; return []; }
        if (data) {
          const arr = Array.isArray(data.wishes) ? data.wishes : (Array.isArray(data) ? data : []);
          return arr.map(migrateWish);
        }
      }
      publicViewData = null;
      try {
        return JSON.parse(safeGetItem(WISHES_KEY) || '[]').map(migrateWish);
      } catch (_) { return []; }
    }

    async function handleInviteJoin(data) {
      const wl = data.wishlist;
      const wlWishes = data.wishes || [];
      if (!wl?.id) return;
      if (useSupabase) {
        await ensureUser();
        await sb.from('wishlist_collaborators').upsert({ wishlist_id: wl.id, user_id: currentUserId }, { onConflict: 'wishlist_id,user_id' });
      } else {
        const wls = JSON.parse(safeGetItem(WISHLISTS_KEY) || '[]');
        const wis = JSON.parse(safeGetItem(WISHES_KEY) || '[]').map(migrateWish);
        const existing = wls.find((x) => x.id === wl.id);
        const coAuthorIds = Array.isArray(wl.coAuthorIds) ? [...wl.coAuthorIds] : (wl.ownerId ? [wl.ownerId] : []);
        if (!coAuthorIds.includes(currentUserId)) coAuthorIds.push(currentUserId);
        const mergedWl = { ...wl, coAuthorIds };
        let newWls = existing ? wls.map((x) => x.id === wl.id ? { ...x, ...mergedWl, coAuthorIds: [...new Set([...(x.coAuthorIds || []), currentUserId])] } : x) : [...wls, mergedWl];
        const newWis = [...wis];
        wlWishes.forEach((w) => {
          const mw = migrateWish({ ...w, wishlistIds: [...(Array.isArray(w.wishlistIds) ? w.wishlistIds : []), wl.id].filter((x, i, a) => a.indexOf(x) === i) });
          const ei = newWis.findIndex((x) => x.id === mw.id);
          if (ei >= 0) { if (!newWis[ei].wishlistIds?.includes(wl.id)) newWis[ei].wishlistIds = [...(newWis[ei].wishlistIds || []), wl.id]; }
          else newWis.push(mw);
        });
        safeSetItem(WISHLISTS_KEY, JSON.stringify(newWls));
        safeSetItem(WISHES_KEY, JSON.stringify(newWis));
      }
      window.location.hash = '';
      window.location.reload();
    }

    function getStartParam() {
      console.log('=== getStartParam() called ===');
      console.log('window.location.href:', window.location.href);
      console.log('window.location.search:', window.location.search);
      console.log('window.location.hash:', window.location.hash);
      console.log('tg object:', tg);
      console.log('tg?.initDataUnsafe:', tg?.initDataUnsafe);
      console.log('tg?.initDataUnsafe?.start_param:', tg?.initDataUnsafe?.start_param);
      
      // Проверяем сохраненный параметр
      if (_savedStartParam) {
        console.log('✓ Using saved start param:', _savedStartParam);
        return _savedStartParam;
      }
      
      // Проверяем query параметры URL (?start_param=...)
      const urlParams = new URLSearchParams(window.location.search);
      const urlStartParam = urlParams.get('start_param');
      if (urlStartParam) {
        console.log('✓ Start param from URL query:', urlStartParam);
        return urlStartParam;
      }
      
      // Проверяем все query параметры
      console.log('All URL params:', Object.fromEntries(urlParams));
      
      // Проверяем hash параметры
      const h = window.location.hash.slice(1);
      if (h) {
        console.log('Hash content:', h);
        try {
          const hashParams = new URLSearchParams(h);
          console.log('Hash params:', Object.fromEntries(hashParams));
          
          // Проверяем tgWebAppStartParam
          const sp = hashParams.get('tgWebAppStartParam');
          if (sp) {
            console.log('✓ Start param from hash (tgWebAppStartParam):', sp);
            return sp;
          }
          
          // Проверяем start_param напрямую в hash
          const startParamFromHash = hashParams.get('start_param');
          if (startParamFromHash) {
            console.log('✓ Start param from hash (start_param):', startParamFromHash);
            return startParamFromHash;
          }
        } catch (e) {
          console.error('Error parsing hash:', e);
          // Если hash не является валидным URLSearchParams, пробуем как есть
          if (h.startsWith('start_param=')) {
            const sp = decodeURIComponent(h.split('=').slice(1).join('='));
            console.log('✓ Start param from hash (raw):', sp);
            return sp;
          }
        }
      }
      
      // Проверяем Telegram initData напрямую
      const tgParam = tg?.initDataUnsafe?.start_param || '';
      console.log('Telegram initData start_param:', tgParam);
      
      // Также проверяем через initData строку напрямую
      if (tg?.initData) {
        try {
          const initDataParams = new URLSearchParams(tg.initData);
          const initDataStartParam = initDataParams.get('start_param');
          if (initDataStartParam) {
            console.log('✓ Start param from initData string:', initDataStartParam);
            return initDataStartParam;
          }
        } catch (e) {
          console.error('Error parsing initData:', e);
        }
      }
      
      console.log('✗ No start param found');
      return tgParam;
    }

    async function loadAll() {
      let hash = window.location.hash.slice(1);
      const goHome = sessionStorage.getItem('publicViewGoHome');
      if (goHome) { sessionStorage.removeItem('publicViewGoHome'); hash = ''; }
      const startParam = goHome ? '' : getStartParam();
      console.log('=== loadAll() ===');
      console.log('Full URL:', window.location.href);
      console.log('Start param received:', startParam);
      console.log('Start param type:', typeof startParam);
      console.log('Start param length:', startParam?.length);
      
      if (startParam && startParam.startsWith('img_')) {
        console.log('✓ Processing image from bot...');
        const param = startParam.slice(4); // Убираем "img_"
        console.log('Param after removing "img_":', param);
        
        // Загружаем данные перед обработкой изображения
        await ensureUser();
        if (useSupabase && sb) {
          const wlRes = await loadWishlistsFromSupabase();
          if (wlRes.data) wishlists = wlRes.data;
          wishes = await loadWishesFromSupabase(new Set(wishlists.map((w) => w.id)));
          wishes = Array.isArray(wishes) ? wishes : [];
          const cats = await loadCategoriesFromSupabase();
          categories = Array.isArray(cats) && cats.length ? cats : [...DEFAULT_CATS];
        } else {
          wishes = loadWishesSync();
          wishes = Array.isArray(wishes) ? wishes : [];
          try { wishlists = (JSON.parse(safeGetItem(WISHLISTS_KEY) || '[]')).map(migrateWishlist); } catch (_) { wishlists = []; }
          wishlists = Array.isArray(wishlists) ? wishlists : [];
          try { const raw = safeGetItem(CATS_KEY); categories = raw ? JSON.parse(raw) : [...DEFAULT_CATS]; } catch (_) { categories = [...DEFAULT_CATS]; }
          categories = Array.isArray(categories) ? categories : [...DEFAULT_CATS];
        }
        
        // Сохраняем загруженные данные в глобальные переменные
        console.log('Данные загружены:', { 
          wishlists: wishlists.length, 
          wishes: wishes.length, 
          categories: categories.length 
        });
        
        if (param.startsWith('url_')) {
          const encodedUrl = param.slice(4); // Убираем "url_"
          console.log('Encoded URL:', encodedUrl);
          const imageUrl = decodeImageUrl(encodedUrl);
          console.log('Decoded Image URL:', imageUrl);
          if (imageUrl) {
            console.log('Calling handleImageFromBot with URL...');
            // Вызываем handleImageFromBot, но не ждем его завершения для рендеринга
            handleImageFromBot(null, imageUrl).catch(e => {
              console.error('Ошибка в handleImageFromBot:', e);
              currentView = 'main';
              render();
            });
            // Рендерим интерфейс сразу после начала обработки
            currentView = 'main';
            render();
            return;
          } else {
            console.error('✗ Failed to decode image URL');
            currentView = 'main';
            render();
            return;
          }
        } else {
          console.log('File ID mode, param:', param);
          // Вызываем handleImageFromBot, но не ждем его завершения для рендеринга
          handleImageFromBot(param).catch(e => {
            console.error('Ошибка в handleImageFromBot:', e);
            currentView = 'main';
            render();
          });
          // Рендерим интерфейс сразу после начала обработки
          currentView = 'main';
          render();
          return;
        }
      } else if (startParam) {
        console.log('✗ Start param does not start with img_:', startParam);
        console.log('First 10 chars:', startParam.substring(0, 10));
      } else {
        console.log('No start param found');
      }
      if (startParam && (startParam.startsWith('w_') || startParam.startsWith('i_'))) {
        hash = startParam.replace('_', '/');
      }
      if (hash) {
        const shortW = /^w\/(.+)$/.exec(hash);
        const shortI = /^i\/(.+)$/.exec(hash);
        if (shortW && useSupabase && sb) {
          publicViewData = await fetchPublicWishlistFromSupabase(shortW[1]);
          if (publicViewData) {
            await ensureUser();
            await addFollowedPublicWishlist(shortW[1]);
            wishes = []; categories = [...DEFAULT_CATS]; wishlists = [];
            history.replaceState(null, '', window.location.pathname + '#w/' + shortW[1]);
            return;
          }
        }
        if (shortI && useSupabase && sb) {
          const wlId = shortI[1];
          try {
            if (sessionStorage.getItem('accepted_invite_' + wlId)) {
              sessionStorage.removeItem('accepted_invite_' + wlId);
              hash = '';
            } else if (sessionStorage.getItem('declined_invite_' + wlId)) {
              sessionStorage.removeItem('declined_invite_' + wlId);
              hash = '';
            } else {
              const info = await fetchInviteWishlistFromSupabase(wlId);
              if (info) {
                pendingInviteData = { wlId, ownerName: info.ownerName, wlName: info.wishlist?.name || 'Вишлист' };
                return;
              }
            }
          } catch (_) {}
        }
        const data = unpackPayload(hash);
        if (data?.type === 'public' && data?.wishlist?.id) {
          publicViewData = data;
          if (useSupabase && sb) { await ensureUser(); await addFollowedPublicWishlist(data.wishlist.id); }
          wishes = []; categories = [...DEFAULT_CATS]; wishlists = [];
          return;
        }
        if (data?.type === 'invite' && data?.wishlist?.id) {
          pendingInviteData = {
            wlId: data.wishlist.id,
            ownerName: data.ownerName || 'Пользователь',
            wlName: data.wishlist.name || 'Вишлист',
            fullPayload: data
          };
          return;
        }
      }
      publicViewData = null;
      if (useSupabase && sb) {
        const userRes = await ensureUser();
        if (userRes.error) {
          window._supabaseLoadError = userRes.error.message || JSON.stringify(userRes.error);
          return;
        }
        const wlRes = await loadWishlistsFromSupabase();
        if (wlRes.error) {
          window._supabaseLoadError = wlRes.error.message || JSON.stringify(wlRes.error);
          return;
        }
        wishlists = Array.isArray(wlRes.data) ? wlRes.data : [];
        wishes = await loadWishesFromSupabase(new Set(wishlists.map((w) => w.id)));
        wishes = Array.isArray(wishes) ? wishes : [];
        const cats = await loadCategoriesFromSupabase();
        categories = Array.isArray(cats) && cats.length ? cats : [...DEFAULT_CATS];
      } else {
        wishes = loadWishesSync();
        wishes = Array.isArray(wishes) ? wishes : [];
        try { wishlists = (JSON.parse(safeGetItem(WISHLISTS_KEY) || '[]')).map(migrateWishlist); } catch (_) { wishlists = []; }
        wishlists = Array.isArray(wishlists) ? wishlists : [];
        try { const raw = safeGetItem(CATS_KEY); categories = raw ? JSON.parse(raw) : [...DEFAULT_CATS]; } catch (_) { categories = [...DEFAULT_CATS]; }
        categories = Array.isArray(categories) ? categories : [...DEFAULT_CATS];
      }
    }

    async function saveWishes() {
      if (useSupabase) {
        for (const w of wishes) {
          const row = { id: w.id, name: w.name, image: w.image, price: w.price, currency: w.currency, size: w.size, link: w.link, comment: w.comment, category: w.category, user_id: currentUserId };
          await sb.from('wishes').upsert(row, { onConflict: 'id' });
          await sb.from('wishlist_items').delete().eq('wish_id', w.id);
          for (const wlId of (w.wishlistIds || [])) await sb.from('wishlist_items').insert({ wishlist_id: wlId, wish_id: w.id });
        }
        const { data: dbRows } = await sb.from('wishes').select('id').eq('user_id', currentUserId);
        const localIds = new Set(wishes.map((w) => w.id));
        for (const r of (dbRows || [])) { if (!localIds.has(r.id)) await sb.from('wishes').delete().eq('id', r.id); }
      } else {
        try { safeSetItem(WISHES_KEY, JSON.stringify(wishes)); } catch (e) { tg?.showAlert?.('Не удалось сохранить.'); }
      }
    }

    async function saveCategories() {
      if (useSupabase) {
        await sb.from('categories').delete().eq('user_id', currentUserId);
        for (const name of categories) await sb.from('categories').insert({ user_id: currentUserId, name });
      } else {
        safeSetItem(CATS_KEY, JSON.stringify(categories));
      }
    }

    function migrateWishlist(wl) {
      if (!wl.ownerId) wl.ownerId = wl.owner_id || currentUserId;
      if (!Array.isArray(wl.coAuthorIds) && wl.ownerId) wl.coAuthorIds = [wl.ownerId];
      if (!wl.privacy) wl.privacy = wl.privacy || 'private';
      if (wl.updatedAt == null) wl.updatedAt = wl.updated_at ? new Date(wl.updated_at).getTime() : 0;
      return wl;
    }

    function navigateTo(view, wlId = null) {
      currentView = view;
      selectedWlId = wlId;
      render();
    }
    window.__nav = navigateTo;
    document.addEventListener('click', (e) => {
      const btn = e.target.closest('[data-nav]');
      if (btn) { e.preventDefault(); try { navigateTo(btn.dataset.nav); } catch (err) { console.error('nav err:', err); } return; }
      const back = e.target.closest('[data-nav-back]');
      if (back) { e.preventDefault(); navigateTo('main'); return; }
      const recent = e.target.closest('.recent-item[data-wl-id]');
      if (recent) { e.preventDefault(); navigateTo('wishlist', recent.dataset.wlId); }
    });

    function renderMain() {
      const content = document.getElementById('content');
      const visibleWishlists = wishlists.filter((wl) => {
        if (wl.privacy === 'private') return wl.ownerId === currentUserId;
        if (wl.privacy === 'shared') return canEditWishlist(wl);
        return true;
      });
      const recent = [...visibleWishlists]
        .sort((a, b) => (b.updatedAt || 0) - (a.updatedAt || 0))
        .slice(0, 3);

      content.innerHTML = `
        <div class="main-buttons">
          <button class="btn" data-nav="manageWishlists">Вишлисты</button>
          <button class="btn btn-secondary" data-nav="manageCategories">Категории</button>
          <button class="btn btn-secondary" data-nav="manageWishes">Желания</button>
        </div>
        <h3 class="section-title">Недавно изменённые</h3>
        <div class="recent-list" id="recentList">
          ${recent.length === 0
            ? '<p style="color:var(--text-secondary);font-size:0.9rem;">Нет вишлистов</p>'
            : recent.map((wl) => `
              <div class="recent-item" data-wl-id="${escapeHtml(wl.id)}">
                ${wl.image ? `<img src="${escapeHtml(wl.image)}" alt="">` : '<div style="width:44px;height:44px;background:var(--border);border-radius:8px;"></div>'}
                <span>${escapeHtml(wl.name)}</span>
              </div>
            `).join('')}
        </div>
      `;

      content.querySelectorAll('[data-nav]').forEach((b) => {
        b.addEventListener('click', () => navigateTo(b.dataset.nav));
      });
      content.querySelectorAll('.recent-item').forEach((el) => {
        el.addEventListener('click', () => navigateTo('wishlist', el.dataset.wlId));
      });
    }

    function canEditWishlist(wl) {
      if (!wl) return false;
      return wl.ownerId === currentUserId || (Array.isArray(wl.coAuthorIds) && wl.coAuthorIds.includes(currentUserId));
    }

    function isOwner(wl) {
      return wl?.ownerId === currentUserId;
    }

    async function saveWishlists() {
      if (useSupabase) {
        const ourIds = new Set(wishlists.map((w) => w.id));
        const { data: owned } = await sb.from('wishlists').select('id').eq('owner_id', currentUserId);
        for (const r of (owned || [])) {
          if (!ourIds.has(r.id)) await sb.from('wishlists').delete().eq('id', r.id);
        }
        for (const wl of wishlists) {
          const row = { id: wl.id, name: wl.name, image: wl.image, privacy: wl.privacy || 'private', owner_id: wl.ownerId || currentUserId };
          if (wl.updatedAt) row.updated_at = new Date(wl.updatedAt).toISOString();
          await sb.from('wishlists').upsert(row, { onConflict: 'id' });
          await sb.from('wishlist_collaborators').delete().eq('wishlist_id', wl.id);
          for (const uid of (wl.coAuthorIds || [])) {
            if (uid !== (wl.ownerId || wl.owner_id)) await sb.from('wishlist_collaborators').insert({ wishlist_id: wl.id, user_id: uid });
          }
        }
      } else {
        safeSetItem(WISHLISTS_KEY, JSON.stringify(wishlists));
      }
    }

    function escapeHtml(s) {
      const d = document.createElement('div');
      d.textContent = s ?? '';
      return d.innerHTML;
    }

    function resizeImageBase64(base64, maxW = 800, quality = 0.8) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const w = img.width, h = img.height;
          if (w <= maxW) { resolve(base64); return; }
          const canvas = document.createElement('canvas');
          canvas.width = maxW;
          canvas.height = (h / w) * maxW;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
          resolve(canvas.toDataURL('image/jpeg', quality));
        };
        img.onerror = () => resolve(base64);
        img.src = base64;
      });
    }

    function fileToBase64(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(file);
      });
    }

    function validateName(v) {
      if (!v || !v.trim()) return 'Обязательное поле';
      if (v.length > 100) return 'Макс. 100 символов';
      if (!NAME_RE.test(v)) return 'Только латиница и кириллица';
      return null;
    }

    function validateLink(v) {
      if (!v?.trim()) return null;
      if (!URL_RE.test(v.trim())) return 'Некорректная ссылка';
      return null;
    }

    function validatePrice(v) {
      if (!v) return null;
      const n = parseInt(v, 10);
      if (isNaN(n) || n < 1 || n > 9999999) return 'Число от 1 до 9999999';
      return null;
    }

    function validateSize(v) {
      if (!v?.trim()) return null;
      if (!SIZE_RE.test(v.trim())) return 'Только латиница и цифры';
      return null;
    }

    function validateComment(v) {
      if (!v?.trim()) return null;
      if (v.length > 500) return 'Макс. 500 символов';
      return null;
    }

    function formatPrice(price, currency) {
      if (!price) return '';
      const n = parseInt(price, 10);
      if (isNaN(n)) return price;
      const fmt = new Intl.NumberFormat('ru-RU').format(n);
      return currency ? `${fmt} ${currency}` : fmt;
    }

    function render() {
      if (!Array.isArray(wishlists)) wishlists = [];
      if (!Array.isArray(wishes)) wishes = [];
      if (!Array.isArray(categories)) categories = [...DEFAULT_CATS];
      if (pendingInviteData) {
        document.getElementById('inviteConsentText').textContent = `${pendingInviteData.ownerName} приглашает вас стать соавтором вишлиста «${pendingInviteData.wlName}». Вы сможете добавлять и редактировать желания.`;
        document.getElementById('inviteConsentModal').classList.add('open');
        return;
      }
      if (publicViewData) {
        renderPublicView();
        if (!shareWelcomeShown) {
          const owner = publicViewData.ownerName || 'Пользователь';
          const wlName = publicViewData.wishlist?.name || 'Вишлист';
          document.getElementById('shareWelcomeText').textContent = `${owner} поделился с вами вишлистом «${wlName}». Вы можете забронировать любое желание.`;
          document.getElementById('shareWelcomeModal').classList.add('open');
          shareWelcomeShown = true;
        }
        return;
      }
      const content = document.getElementById('content');
      if (!content) return;
      if (currentView === 'main') {
        renderMain();
        return;
      }
      if (currentView === 'manageWishlists') {
        renderManageWishlists();
        return;
      }
      if (currentView === 'manageCategories') {
        renderManageCategories();
        return;
      }
      if (currentView === 'manageWishes') {
        renderManageWishes();
        return;
      }
      if (currentView === 'wishlist' && selectedWlId) {
        renderWishlistDetail(selectedWlId);
        return;
      }
      renderMain();
    }

    function renderManageWishlists() {
      const content = document.getElementById('content');
      content.innerHTML = `
        <button class="btn back-btn" data-nav-back>← Назад</button>
        <h2 style="margin-bottom:20px;">Вишлисты</h2>
        <div id="wlList" class="wl-manage-list"></div>
        <div id="wlAddForm" class="wl-form-section" style="margin-top:24px;">
          <h3 style="margin-bottom:12px;">Добавить вишлист</h3>
          <div class="form-group">
            <label><span class="required">*</span> Название</label>
            <input type="text" id="newWlName" placeholder="Название вишлиста">
          </div>
          <div class="form-group">
            <label>Обложка</label>
            <div class="img-upload wl-add-img" id="wlImgUpload">
              <input type="file" id="wlImage" accept="image/*">
              <span id="wlImgText">Добавить обложку (необязательно)</span>
              <img id="wlImgPreview" class="img-preview" style="display:none;max-height:120px;" alt="">
            </div>
          </div>
          <div class="form-group">
            <label>Приватность</label>
            <select id="newWlPrivacy">
              <option value="private">Приватный</option>
              <option value="public">Публичный</option>
              <option value="shared">Совместный</option>
            </select>
          </div>
          <div class="form-actions" style="margin-top:16px;">
            <button type="button" class="btn" id="addWlBtn">Добавить</button>
          </div>
        </div>
        <div id="wlEditForm" style="display:none;"></div>
      `;
      content.querySelector('[data-nav-back]').addEventListener('click', () => navigateTo('main'));
      refreshWlManageList();
      bindWlManageHandlers();
    }

    function refreshWlManageList() {
      const list = document.getElementById('wlList');
      if (!list) return;
      list.innerHTML = wishlists.length === 0
        ? '<div class="empty-cats">Вишлистов нет. Добавь первый.</div>'
        : wishlists.map((wl) => {
            const pr = wl.privacy === 'private' ? 'Приватный' : (wl.privacy === 'public' ? 'Публичный' : 'Совместный');
            const shareBtn = wl.privacy === 'public' && isOwner(wl) ? `<button class="btn btn-sm btn-secondary" data-wl-share="${escapeHtml(wl.id)}">Поделиться</button>` : '';
            const inviteBtn = wl.privacy === 'shared' && isOwner(wl) ? `<button class="btn btn-sm btn-secondary" data-wl-invite="${escapeHtml(wl.id)}">Пригласить</button>` : '';
            const isCollab = wl.privacy === 'shared' && canEditWishlist(wl) && !isOwner(wl);
            const isFollowed = !!wl.isFollowedPublic;
            const removeOrLeave = (isCollab || isFollowed)
              ? `<span class="wl-item-leave" data-wl-id="${escapeHtml(wl.id)}" data-followed="${isFollowed}" style="color:var(--accent);cursor:pointer;padding:4px;font-size:0.85rem;">Покинуть</span>`
              : (isOwner(wl) ? `<span class="wl-item-remove" data-wl-id="${escapeHtml(wl.id)}">✕</span>` : '');
            const editBtn = isFollowed ? '' : `<span class="wl-item-edit" data-wl-id="${escapeHtml(wl.id)}" title="Редактировать">✎</span>`;
            return `
              <div class="wl-item" data-wl-id="${escapeHtml(wl.id)}">
                ${wl.image ? `<img class="wl-item-img" src="${escapeHtml(wl.image)}" alt="">` : '<div class="wl-item-img" style="background:var(--border);flex-shrink:0;"></div>'}
                <div class="wl-item-body">
                  <div>${escapeHtml(wl.name)}</div>
                  <span class="privacy-badge" style="font-size:0.7rem;margin-top:4px;display:inline-block;">${escapeHtml(pr)}</span>
                  <div style="margin-top:8px;">${shareBtn}${inviteBtn}</div>
                </div>
                ${editBtn}
                ${removeOrLeave}
              </div>`;
          }).join('');
      list.querySelectorAll('.wl-item-edit').forEach((el) => el.addEventListener('click', () => openEditWlFormInManage(el.dataset.wlId)));
      list.querySelectorAll('.wl-item-remove').forEach((el) => el.addEventListener('click', () => removeWlInManage(el.dataset.wlId)));
      list.querySelectorAll('.wl-item-leave').forEach((el) => el.addEventListener('click', async () => {
        const wlId = el.dataset.wlId;
        if (el.dataset.followed === 'true') {
          await leaveFollowedPublicWishlist(wlId);
          if (useSupabase && sb) { const r = await loadWishlistsFromSupabase(); if (r.data) wishlists = r.data; } else wishlists = wishlists.filter((x) => x.id !== wlId);
        } else {
          await leaveWishlist(wlId);
        }
        refreshWlManageList(); bindWlManageHandlers(); render();
      }));
      list.querySelectorAll('[data-wl-share]').forEach((b) => b.addEventListener('click', () => openShareModal(b.dataset.wlShare)));
      list.querySelectorAll('[data-wl-invite]').forEach((b) => b.addEventListener('click', () => openInviteModal(b.dataset.wlInvite)));
    }

    function bindWlManageHandlers() {
      document.getElementById('addWlBtn')?.addEventListener('click', addWlInManage);
      document.getElementById('wlImage')?.addEventListener('change', async (e) => {
        const f = e.target.files?.[0];
        if (!f?.type?.startsWith('image/')) return;
        try {
          let b = await fileToBase64(f);
          b = await resizeImageBase64(b, 400);
          pendingWlImageBase64 = b;
          const prev = document.getElementById('wlImgPreview');
          const txt = document.getElementById('wlImgText');
          if (prev) { prev.src = b; prev.style.display = 'block'; }
          if (txt) txt.textContent = 'Файл выбран';
        } catch (_) {}
      });
      document.getElementById('wlImgUpload')?.addEventListener('click', () => document.getElementById('wlImage')?.click());
    }

    async function addWlInManage() {
      const name = document.getElementById('newWlName')?.value?.trim();
      if (!name || validateName(name)) return;
      const wl = { id: 'wl_' + Date.now(), name, image: pendingWlImageBase64 || null, privacy: document.getElementById('newWlPrivacy')?.value || 'private', ownerId: currentUserId, coAuthorIds: [currentUserId], updatedAt: Date.now() };
      wishlists.push(wl);
      await saveWishlists();
      pendingWlImageBase64 = null;
      document.getElementById('newWlName').value = '';
      const prev = document.getElementById('wlImgPreview');
      if (prev) { prev.style.display = 'none'; prev.src = ''; }
      const txt = document.getElementById('wlImgText');
      if (txt) txt.textContent = 'Добавить обложку (необязательно)';
      document.getElementById('wlImage').value = '';
      refreshWlManageList();
      render();
    }

    async function removeCollaborator(wlId, userId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl || !isOwner(wl)) return;
      if (useSupabase && sb) {
        await sb.from('wishlist_collaborators').delete().eq('wishlist_id', wlId).eq('user_id', userId);
      }
      if (wl.coAuthorIds) wl.coAuthorIds = wl.coAuthorIds.filter((id) => id !== userId);
      await saveWishlists();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    }

    async function removeWlInManage(wlId) {
      wishes.forEach((w) => { const ids = Array.isArray(w.wishlistIds) ? w.wishlistIds : []; w.wishlistIds = ids.filter((id) => id !== wlId); });
      wishlists = wishlists.filter((x) => x.id !== wlId);
      await saveWishlists();
      await saveWishes();
      refreshWlManageList();
      render();
    }

    async function leaveWishlist(wlId) {
      if (useSupabase && sb) {
        await sb.from('wishlist_collaborators').delete().eq('wishlist_id', wlId).eq('user_id', currentUserId);
        const res = await loadWishlistsFromSupabase();
        wishlists = res.data || wishlists.filter((x) => x.id !== wlId);
      } else {
        const wl = wishlists.find((x) => x.id === wlId);
        if (wl?.coAuthorIds) wl.coAuthorIds = wl.coAuthorIds.filter((id) => id !== currentUserId);
        wishlists = wishlists.filter((x) => x.id !== wlId);
        await saveWishlists();
      }
      wishes.forEach((w) => { const ids = Array.isArray(w.wishlistIds) ? w.wishlistIds : []; w.wishlistIds = ids.filter((id) => id !== wlId); });
      await saveWishes();
      editingWlId = null;
      document.getElementById('wlAddForm').style.display = 'block';
      document.getElementById('wlEditForm').style.display = 'none';
      document.getElementById('wlEditForm').innerHTML = '';
      refreshWlManageList();
      render();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    }

    function openEditWlFormInManage(wlId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl) return;
      editingWlId = wlId;
      document.getElementById('wlAddForm').style.display = 'none';
      let editForm = document.getElementById('wlEditForm');
      editForm.style.display = 'block';
      editForm.innerHTML = `
        <h3 style="margin-bottom:12px;">Редактировать вишлист</h3>
        <div class="form-group">
          <label><span class="required">*</span> Название</label>
          <input type="text" id="editWlName" value="${escapeHtml(wl.name)}" placeholder="Название вишлиста">
        </div>
        <div class="form-group">
          <label>Приватность</label>
          <select id="editWlPrivacy">
            <option value="private" ${wl.privacy === 'private' ? 'selected' : ''}>Приватный</option>
            <option value="public" ${wl.privacy === 'public' ? 'selected' : ''}>Публичный</option>
            <option value="shared" ${wl.privacy === 'shared' ? 'selected' : ''}>Совместный</option>
          </select>
        </div>
        <div class="form-group">
          <label>Картинка</label>
          <div class="img-upload wl-add-img" id="wlImgUploadEdit">
            <input type="file" id="wlImageEdit" accept="image/*">
            <span id="wlImgTextEdit">Обложка</span>
            <img id="wlImgPreviewEdit" class="img-preview" style="display:${wl.image ? 'block' : 'none'};max-height:120px;" src="${wl.image || ''}" alt="">
          </div>
        </div>
        <div id="wlEditFormExtrasManage"></div>
        <div class="form-actions" style="margin-top:16px;">
          <button type="button" class="btn btn-secondary" id="editWlCancel">Отмена</button>
          <button type="button" class="btn" id="editWlSave">Сохранить</button>
        </div>
      `;
      const extras = document.getElementById('wlEditFormExtrasManage');
      const isCollab = wl.privacy === 'shared' && canEditWishlist(wl) && !isOwner(wl);
      if (isCollab) {
        extras.innerHTML = '<button type="button" class="btn btn-secondary" id="editWlLeaveManage" style="margin-top:12px;">Покинуть вишлист</button>';
        document.getElementById('editWlLeaveManage').addEventListener('click', async () => { await leaveWishlist(wlId); });
      } else if (wl.privacy === 'shared' && isOwner(wl)) {
        const coAuths = (wl.coAuthorIds || []).filter((id) => id !== (wl.ownerId || wl.owner_id));
        if (coAuths.length > 0) {
          Promise.all(coAuths.map(async (uid) => {
            if (useSupabase && sb) {
              const { data } = await sb.from('users').select('first_name, username').eq('id', uid).single();
              return data ? (data.username ? '@' + data.username : data.first_name || uid) : uid;
            }
            return uid;
          })).then((names) => {
            extras.innerHTML = `
              <div class="form-group" style="margin-top:12px;">
                <label>Удалить соавтора</label>
                <select id="editWlRemoveCollabManage" style="width:100%;padding:8px 12px;margin-top:4px;border-radius:8px;background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border);">
                  <option value="">— Выберите —</option>
                  ${coAuths.map((id, i) => `<option value="${escapeHtml(id)}">${escapeHtml(names[i] || id)}</option>`).join('')}
                </select>
                <button type="button" class="btn btn-secondary btn-sm" id="editWlRemoveCollabBtnManage" style="margin-top:8px;">Удалить</button>
              </div>`;
            document.getElementById('editWlRemoveCollabBtnManage').addEventListener('click', async () => {
              const uid = document.getElementById('editWlRemoveCollabManage').value;
              if (!uid) return;
              await removeCollaborator(wlId, uid);
              openEditWlFormInManage(wlId);
            });
          });
        }
      }
      document.getElementById('editWlName').focus();
      document.getElementById('editWlCancel').addEventListener('click', () => { editingWlId = null; document.getElementById('wlAddForm').style.display = 'block'; document.getElementById('wlEditForm').style.display = 'none'; document.getElementById('wlEditForm').innerHTML = ''; renderManageWishlists(); });
      document.getElementById('editWlSave').addEventListener('click', saveEditWlInManage);
      document.getElementById('wlImageEdit').addEventListener('change', (e) => {
        const f = e.target.files?.[0];
        if (f) fileToBase64(f).then((b) => { document.getElementById('wlImgPreviewEdit').src = b; document.getElementById('wlImgPreviewEdit').style.display = 'block'; document.getElementById('wlImgTextEdit').textContent = 'Файл выбран'; pendingEditWlImage = b; });
      });
      document.getElementById('wlImgUploadEdit').addEventListener('click', () => document.getElementById('wlImageEdit').click());
    }

    let pendingEditWlImage = null;
    async function saveEditWlInManage() {
      const wl = wishlists.find((x) => x.id === editingWlId);
      if (!wl) return;
      const name = document.getElementById('editWlName')?.value?.trim();
      if (!name || validateName(name)) return;
      wl.name = name;
      wl.privacy = document.getElementById('editWlPrivacy')?.value || 'private';
      if (pendingEditWlImage) wl.image = pendingEditWlImage;
      wl.updatedAt = Date.now();
      pendingEditWlImage = null;
      await saveWishlists();
      editingWlId = null;
      renderManageWishlists();
    }

    function renderManageCategories() {
      const content = document.getElementById('content');
      content.innerHTML = `
        <button class="btn back-btn" data-nav-back>← Назад</button>
        <h2 style="margin-bottom:20px;">Категории</h2>
        <div id="catList" class="cat-list"></div>
        <div class="cat-add" style="margin-top:16px;">
          <input type="text" id="newCatName" placeholder="Новая категория">
          <button class="btn" id="addCatBtn">Добавить</button>
        </div>
      `;
      content.querySelector('[data-nav-back]').addEventListener('click', () => navigateTo('main'));
      const list = document.getElementById('catList');
      list.innerHTML = categories.length === 0
        ? '<div class="empty-cats">Категорий нет. Добавь свою.</div>'
        : categories.map((c) => `
            <div class="cat-item" data-cat="${escapeHtml(c)}">
              <span>${escapeHtml(c)}</span>
              <span class="cat-item-remove" data-cat="${escapeHtml(c)}">✕</span>
            </div>`).join('');
      list.querySelectorAll('.cat-item-remove').forEach((el) => {
        el.addEventListener('click', async () => {
          categories = categories.filter((x) => x !== el.dataset.cat);
          await saveCategories();
          renderManageCategories();
        });
      });
      document.getElementById('addCatBtn').addEventListener('click', async () => {
        const v = document.getElementById('newCatName').value.trim();
        if (!v || !/^[a-zA-Zа-яА-ЯёЁ0-9\s\-_]+$/.test(v)) return;
        if (categories.includes(v)) return;
        categories.push(v);
        await saveCategories();
        document.getElementById('newCatName').value = '';
        renderManageCategories();
      });
      document.getElementById('newCatName').addEventListener('keydown', (e) => { if (e.key === 'Enter') document.getElementById('addCatBtn').click(); });
    }

    function getMyWishes() {
      return wishes.filter((w) => {
        const ids = w.wishlistIds || [];
        return ids.some((id) => { const wl = wishlists.find((x) => x.id === id); return wl && !wl.isFollowedPublic; });
      });
    }

    function renderManageWishes() {
      const content = document.getElementById('content');
      content.innerHTML = `
        <button class="btn back-btn" data-nav-back>← Назад</button>
        <h2 style="margin-bottom:20px;">Желания</h2>
        <button class="btn" id="addWishBtn" style="margin-bottom:16px;">+ Добавить желание</button>
        <div id="wishList" class="wishlist"></div>
      `;
      content.querySelector('[data-nav-back]').addEventListener('click', () => navigateTo('main'));
      document.getElementById('addWishBtn').addEventListener('click', () => openWishModal());

      const myWishes = getMyWishes();
      const list = document.getElementById('wishList');
      if (myWishes.length === 0) {
        list.innerHTML = '<div class="empty-state"><p>Нет желаний. Нажми «Добавить желание».</p></div>';
        return;
      }
      const byCat = {};
      myWishes.forEach((w) => { const c = w.category || 'Без категории'; if (!byCat[c]) byCat[c] = []; byCat[c].push(w); });
      const catOrder = [...categories, 'Без категории'].filter((c) => byCat[c]?.length);
      Object.keys(byCat).forEach((c) => { if (!catOrder.includes(c)) catOrder.push(c); });
      list.innerHTML = catOrder.map((catName) => {
        const items = byCat[catName] || [];
        return `
          <div class="categories-section">
            <div class="category-title"><span class="count">${items.length}</span> ${escapeHtml(catName)}</div>
            <div class="wishlist">${items.map((w) => renderCard(w, { type: 'standalone' }, null)).join('')}</div>
          </div>`;
      }).join('');
      list.querySelectorAll('.btn-edit').forEach((b) => b.addEventListener('click', () => openWishModal(b.dataset.id)));
      list.querySelectorAll('.btn-del').forEach((b) => b.addEventListener('click', () => deleteWish(b.dataset.id).then(() => render()).catch(() => {})));
      list.querySelectorAll('.btn-move').forEach((b) => b.addEventListener('click', (e) => toggleMoveMenu(e, b.dataset.id)));
    }

    async function renderWishlistDetail(wlId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl) { navigateTo('main'); return; }
      if (wl.isFollowedPublic) {
        await renderFollowedPublicDetail(wlId);
        return;
      }
      const content = document.getElementById('content');
      const getIds = (w) => (Array.isArray(w.wishlistIds) ? w.wishlistIds : []);
      const wlWishes = wishes.filter((w) => getIds(w).includes(wlId));
      const byCat = {};
      wlWishes.forEach((w) => { const c = w.category || 'Без категории'; if (!byCat[c]) byCat[c] = []; byCat[c].push(w); });
      const catOrder = [...categories, 'Без категории'].filter((c) => byCat[c]?.length);
      Object.keys(byCat).forEach((c) => { if (!catOrder.includes(c)) catOrder.push(c); });
      const pr = wl.privacy;
      const prLabel = pr === 'private' ? 'Приватный' : (pr === 'public' ? 'Публичный' : (pr === 'shared' ? 'Совместный' : ''));
      const shareBtn = pr === 'public' && isOwner(wl) ? `<button class="btn btn-sm btn-secondary" data-wl-share="${wl.id}">Поделиться</button>` : '';
      const inviteBtn = pr === 'shared' && isOwner(wl) ? `<button class="btn btn-sm btn-secondary" data-wl-invite="${wl.id}">Пригласить</button>` : '';
      const sec = { type: 'wishlist', wl, wishes: wlWishes };

      content.innerHTML = `
        <button class="btn back-btn" data-nav-back>← Назад</button>
        <div class="wl-section-header" style="margin-bottom:16px;">
          ${wl.image ? `<img class="wl-section-img" src="${escapeHtml(wl.image)}" alt="">` : ''}
          <span class="wl-section-title">${escapeHtml(wl.name)}</span>
          ${prLabel ? `<span class="privacy-badge">${escapeHtml(prLabel)}</span>` : ''}
          <span class="wl-header-actions">${shareBtn}${inviteBtn}</span>
        </div>
        <button class="btn" id="addWishToWl" style="margin-bottom:16px;">+ Добавить желание</button>
        <div id="wlWishlistCards" class="wl-section-body"></div>
      `;
      content.querySelector('[data-nav-back]').addEventListener('click', () => navigateTo('main'));

      const cardsEl = document.getElementById('wlWishlistCards');
      cardsEl.innerHTML = catOrder.length === 0
        ? '<div class="empty-state"><p>Нет желаний в этом вишлисте.</p></div>'
        : catOrder.map((catName) => {
            const items = byCat[catName] || [];
            return `
              <div class="categories-section">
                <div class="category-title"><span class="count">${items.length}</span> ${escapeHtml(catName)}</div>
                <div class="wishlist">${items.map((w) => renderCard(w, sec, null)).join('')}</div>
              </div>`;
          }).join('');

      content.querySelector('#addWishToWl')?.addEventListener('click', () => { openWishModal(null, wlId); });
      content.querySelectorAll('[data-wl-share]').forEach((b) => b.addEventListener('click', () => openShareModal(b.dataset.wlShare)));
      content.querySelectorAll('[data-wl-invite]').forEach((b) => b.addEventListener('click', () => openInviteModal(b.dataset.wlInvite)));
      cardsEl.querySelectorAll('.btn-edit').forEach((b) => b.addEventListener('click', () => openWishModal(b.dataset.id)));
      cardsEl.querySelectorAll('.btn-del').forEach((b) => b.addEventListener('click', () => deleteWish(b.dataset.id).then(() => { wl.updatedAt = Date.now(); saveWishlists(); render(); }).catch(() => {})));
      cardsEl.querySelectorAll('.btn-move').forEach((b) => b.addEventListener('click', (e) => toggleMoveMenu(e, b.dataset.id)));
    }

    async function renderFollowedPublicDetail(wlId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl?.isFollowedPublic) return;
      const getIds = (w) => (Array.isArray(w.wishlistIds) ? w.wishlistIds : []);
      const wlWishes = wishes.filter((w) => getIds(w).includes(wlId));
      let reservedCards = {};
      if (useSupabase && sb && wlWishes.length) {
        const wishIds = wlWishes.map((w) => w.id);
        const { data: resRows } = await sb.from('reservations').select('wish_id, user_id, user_name').in('wish_id', wishIds);
        (resRows || []).forEach((r) => { reservedCards[r.wish_id] = { userId: r.user_id, userName: r.user_name || 'Кто-то' }; });
      }
      const byCat = {};
      wlWishes.forEach((w) => { const c = w.category || 'Без категории'; if (!byCat[c]) byCat[c] = []; byCat[c].push(w); });
      const catOrder = Object.keys(byCat);
      const content = document.getElementById('content');
      const d = { wishlist: wl, wishes: wlWishes, reservedCards, ownerName: '' };
      content.innerHTML = `
        <button class="btn back-btn" data-nav-back>← Назад</button>
        <div class="wl-section">
          <div class="wl-section-header">
            ${wl.image ? `<img class="wl-section-img" src="${escapeHtml(wl.image)}" alt="">` : ''}
            <span class="wl-section-title">${escapeHtml(wl.name || 'Вишлист')}</span>
          </div>
          <div class="wl-section-body view-readonly">
            ${catOrder.map((catName) => {
              const catItems = byCat[catName] || [];
              return `
                <div class="categories-section">
                  <div class="category-title"><span class="count">${catItems.length}</span> ${escapeHtml(catName)}</div>
                  <div class="wishlist">${catItems.map((w) => renderCard(w, null, { reserved: reservedCards, items: d })).join('')}</div>
                </div>`;
            }).join('')}
          </div>
        </div>`;
      content.querySelector('[data-nav-back]').addEventListener('click', () => navigateTo('main'));
      content.querySelectorAll('.btn-reserve').forEach((b) => b.addEventListener('click', () => reserveCardInFollowed(wlId, b.dataset.cardId)));
      content.querySelectorAll('.btn-unreserve').forEach((b) => b.addEventListener('click', () => unreserveCardInFollowed(wlId, b.dataset.cardId)));
    }

    async function reserveCardInFollowed(wlId, cardId) {
      if (!useSupabase || !sb) return;
      const u = tg?.initDataUnsafe?.user;
      const userId = u?.id ? 'tg_' + u.id : 'anon_' + Date.now();
      const userName = u?.first_name || 'Кто-то';
      await sb.from('reservations').upsert({ wish_id: cardId, user_id: userId, user_name: userName }, { onConflict: 'wish_id' });
      tg?.HapticFeedback?.notificationOccurred?.('success');
      renderWishlistDetail(wlId);
    }

    async function unreserveCardInFollowed(wlId, cardId) {
      if (!useSupabase || !sb) return;
      const u = tg?.initDataUnsafe?.user;
      const userId = u?.id ? 'tg_' + u.id : null;
      const { data: r } = await sb.from('reservations').select('user_id').eq('wish_id', cardId).single();
      if (!r || (userId && r.user_id !== userId)) return;
      await sb.from('reservations').delete().eq('wish_id', cardId);
      tg?.HapticFeedback?.notificationOccurred?.('success');
      renderWishlistDetail(wlId);
    }

    function renderPublicView() {
      const d = publicViewData;
      const content = document.getElementById('content');
      const wl = d.wishlist || {};
      const items = d.wishes || [];
      const reserved = d.reservedCards || {};
      const byCat = {};
      items.forEach((w) => {
        const c = w.category || 'Без категории';
        if (!byCat[c]) byCat[c] = [];
        byCat[c].push(w);
      });
      const catOrder = Object.keys(byCat);
      content.innerHTML = `
        <button class="btn back-btn" id="publicViewHomeBtn" style="margin-bottom:16px;">🏠 Домой</button>
        <div class="wl-section">
          <div class="wl-section-header">
            ${wl.image ? `<img class="wl-section-img" src="${escapeHtml(wl.image)}" alt="">` : ''}
            <span class="wl-section-title">${escapeHtml(wl.name || 'Вишлист')}</span>
          </div>
          <div class="wl-section-body view-readonly">
            ${catOrder.map((catName) => {
              const catItems = byCat[catName] || [];
              return `
                <div class="categories-section">
                  <div class="category-title"><span class="count">${catItems.length}</span> ${escapeHtml(catName)}</div>
                  <div class="wishlist">${catItems.map((w) => renderCard(w, null, { reserved, items: d })).join('')}</div>
                </div>`;
            }).join('')}
          </div>
        </div>`;
      content.querySelector('#publicViewHomeBtn')?.addEventListener('click', () => {
        sessionStorage.setItem('publicViewGoHome', '1');
        history.replaceState(null, '', window.location.pathname);
        window.location.reload();
      });
      content.querySelectorAll('.btn-reserve').forEach((b) => b.addEventListener('click', () => reserveCard(b.dataset.cardId)));
      content.querySelectorAll('.btn-unreserve').forEach((b) => b.addEventListener('click', () => unreserveCard(b.dataset.cardId)));
    }

    async function reserveCard(cardId) {
      if (!publicViewData) return;
      const u = tg?.initDataUnsafe?.user;
      const userId = u?.id ? 'tg_' + u.id : 'anon_' + Date.now();
      const userName = u?.first_name || 'Кто-то';
      const reserved = { ...(publicViewData.reservedCards || {}) };
      reserved[cardId] = { userId, userName };
      publicViewData.reservedCards = reserved;
      const base = window.location.origin + window.location.pathname;
      const hash = window.location.hash.slice(1);
      if (hash.startsWith('w/') && useSupabase && sb) {
        await sb.from('reservations').upsert({ wish_id: cardId, user_id: userId, user_name: userName }, { onConflict: 'wish_id' });
        history.replaceState(null, '', base + '#' + hash);
      } else {
        history.replaceState(null, '', base + '#' + packPayload(publicViewData));
      }
      render();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    }

    async function unreserveCard(cardId) {
      if (!publicViewData) return;
      const u = tg?.initDataUnsafe?.user;
      const userId = u?.id ? 'tg_' + u.id : null;
      const reserved = publicViewData.reservedCards?.[cardId];
      if (!reserved || (userId && reserved.userId !== userId)) return;
      const next = { ...(publicViewData.reservedCards || {}) };
      delete next[cardId];
      publicViewData.reservedCards = next;
      const base = window.location.origin + window.location.pathname;
      const hash = window.location.hash.slice(1);
      if (hash.startsWith('w/') && useSupabase && sb) {
        await sb.from('reservations').delete().eq('wish_id', cardId);
        history.replaceState(null, '', base + '#' + hash);
      } else {
        history.replaceState(null, '', base + '#' + packPayload(publicViewData));
      }
      render();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    }

    document.addEventListener('click', () => closeMoveMenus());

    function toggleMoveMenu(e, wishId) {
      e.stopPropagation();
      closeMoveMenus();
      const btn = document.querySelector(`.btn-move[data-id="${wishId}"]`);
      if (!btn) return;
      const wrap = btn.closest('.card-move-wrap');
      const w = wishes.find((x) => x.id === wishId);
      const ids = Array.isArray(w?.wishlistIds) ? w.wishlistIds : [];
      const menu = document.createElement('div');
      menu.className = 'card-move-menu';
      wishlists.filter((wl) => !wl.isFollowedPublic).forEach((wl) => {
        const inList = ids.includes(wl.id);
        const opt = document.createElement('button');
        opt.textContent = inList ? `✓ Убрать из «${wl.name}»` : `Добавить в «${wl.name}»`;
        opt.addEventListener('click', async (e2) => { e2.stopPropagation(); await toggleWishWishlist(wishId, wl.id); closeMoveMenus(); });
        menu.appendChild(opt);
      });
      if (menu.children.length === 0) return;
      wrap.appendChild(menu);
    }

    function closeMoveMenus() {
      document.querySelectorAll('.card-move-menu').forEach((m) => m.remove());
    }

    async function toggleWishWishlist(wishId, wlId) {
      const w = wishes.find((x) => x.id === wishId);
      if (!w) return;
      const ids = Array.isArray(w.wishlistIds) ? [...w.wishlistIds] : [];
      const idx = ids.indexOf(wlId);
      if (idx >= 0) ids.splice(idx, 1);
      else ids.push(wlId);
      w.wishlistIds = ids;
      const wl = wishlists.find((x) => x.id === wlId);
      if (wl) wl.updatedAt = Date.now();
      await saveWishes();
      await saveWishlists();
      render();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    }

    function renderCard(w, section, publicViewOpts) {
      const priceStr = formatPrice(w.price, w.currency);
      const isPublicView = !!publicViewOpts;
      const reserved = publicViewOpts?.reserved?.[w.id];
      const reservedClass = reserved ? ' card-reserved' : '';
      const reservedBadge = reserved
        ? `<div class="card-reserved-badge">Забронировано${reserved.userName ? `: ${escapeHtml(reserved.userName)}` : ''}</div>`
        : '';
      const canMove = !isPublicView && wishlists.length > 0;
      const moveBtn = canMove
        ? `<div class="card-move-wrap">
             <button class="btn btn-secondary btn-sm btn-move card-move-btn" data-id="${w.id}">В вишлист</button>
           </div>`
        : '';
      const isReservedByMe = reserved && reserved.userId === currentUserId;
      let reserveBtn = '';
      if (isPublicView) {
        if (!reserved) reserveBtn = `<button class="btn btn-sm btn-reserve" data-card-id="${w.id}">Забронировать</button>`;
        else if (isReservedByMe) reserveBtn = `<button class="btn btn-sm btn-secondary btn-unreserve" data-card-id="${w.id}">Я передумал</button>`;
      }
      const actions = isPublicView
        ? `<div class="card-actions">${reserveBtn}</div>`
        : `<div class="card-actions">
             ${moveBtn}
             <button class="btn btn-secondary btn-sm btn-edit" data-id="${w.id}">Редактировать</button>
             <button class="btn btn-secondary btn-sm btn-del" data-id="${w.id}">Удалить</button>
           </div>`;
      return `
        <div class="card${reservedClass}" data-id="${w.id}">
          <img class="card-img" src="${escapeHtml(w.image || '')}" alt="" onerror="this.style.display='none'">
          <div class="card-title">${escapeHtml(w.name)}</div>
          ${priceStr ? `<div class="card-price">${escapeHtml(priceStr)}</div>` : ''}
          ${w.size ? `<div class="card-meta">Размер: ${escapeHtml(w.size)}</div>` : ''}
          ${w.link ? `<a class="card-link" href="${escapeHtml(w.link)}" target="_blank" rel="noopener">${escapeHtml(w.link)}</a>` : ''}
          ${w.comment ? `<div class="card-comment">${escapeHtml(w.comment)}</div>` : ''}
          ${reservedBadge}
          ${actions}
        </div>`;
    }

    function openWishModalFromImage(imageBase64, extractedData) {
      tg?.HapticFeedback?.impactOccurred?.('light');
      pendingImageBase64 = imageBase64;
      const form = document.getElementById('wishForm');
      form.reset();
      document.getElementById('wishId').value = '';
      document.getElementById('imgPreview').src = imageBase64;
      document.getElementById('imgPreview').style.display = 'block';
      document.getElementById('imgUploadText').textContent = 'Изменить фото';
      ['imgError','nameError','linkError','priceError','sizeError'].forEach((id) => {
        const el = document.getElementById(id);
        if (el) { el.style.display = 'none'; el.textContent = ''; }
      });
      document.getElementById('wishModalTitle').textContent = 'Проверь данные из изображения';
      
      // Включаем предупреждение при открытии формы с данными
      updateClosingConfirmation();
      
      const autoFilled = new Set();
      if (extractedData.name) {
        document.getElementById('wishName').value = extractedData.name;
        autoFilled.add('name');
      }
      if (extractedData.price) {
        document.getElementById('wishPrice').value = String(extractedData.price);
        autoFilled.add('price');
      }
      if (extractedData.currency) {
        document.getElementById('wishCurrency').value = extractedData.currency;
        autoFilled.add('currency');
      }
      if (extractedData.size) {
        document.getElementById('wishSize').value = extractedData.size;
        autoFilled.add('size');
      }
      
      const sel = document.getElementById('wishCategory');
      sel.innerHTML = '<option value="">Без категории</option>' +
        categories.map((c) => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');

      const wlSelect = document.getElementById('wishWishlistSelect');
      const selectedIds = new Set();
      const editableWishlists = wishlists.filter((wl) => !wl.isFollowedPublic);
      const renderMultiselect = () => {
        const names = editableWishlists.filter((wl) => selectedIds.has(wl.id)).map((wl) => wl.name);
        trigger.innerHTML = names.length > 0
          ? names.map((n) => `<span class="multiselect-chip">${escapeHtml(n)}</span>`).join('')
          : '<span class="multiselect-placeholder">Выберите вишлисты</span>';
        panel.querySelectorAll('.multiselect-option').forEach((opt) => opt.classList.toggle('selected', selectedIds.has(opt.dataset.id)));
      };
      wlSelect.innerHTML = editableWishlists.length === 0
        ? '<span style="color:var(--text-secondary);font-size:0.9rem;">Нет вишлистов</span>'
        : `<div class="multiselect-trigger" id="wlMultiselectTrigger"></div>
           <div class="multiselect-panel" id="wlMultiselectPanel">
             ${editableWishlists.map((wl) => `<div class="multiselect-option" data-id="${escapeHtml(wl.id)}">${escapeHtml(wl.name)}</div>`).join('')}
           </div>`;
      const trigger = document.getElementById('wlMultiselectTrigger');
      const panel = document.getElementById('wlMultiselectPanel');
      if (trigger && panel) {
        trigger.addEventListener('click', (e) => { e.stopPropagation(); wlSelect.classList.toggle('open'); });
        panel.querySelectorAll('.multiselect-option').forEach((opt) => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const id = opt.dataset.id;
            if (selectedIds.has(id)) selectedIds.delete(id); else selectedIds.add(id);
            renderMultiselect();
          });
        });
        document.addEventListener('click', () => wlSelect.classList.remove('open'), { once: true });
        wlSelect._getSelectedIds = () => [...selectedIds];
        renderMultiselect();
      }
      
      document.querySelectorAll('.form-group label').forEach((label) => {
        const inputId = label.getAttribute('for');
        if (!inputId) return;
        const fieldName = inputId.replace('wish', '').toLowerCase();
        if (autoFilled.has(fieldName)) {
          label.style.color = 'var(--accent)';
          label.innerHTML = label.textContent + ' <span style="font-size:0.7rem;opacity:0.7;">(автозаполнено)</span>';
        }
      });
      
      updateCounters();
      document.getElementById('wishModal').classList.add('open');
      // Не показываем alert — попап анализа ещё открыт, это вызовет ошибку
    }

    function openWishModal(editId = null, defaultWlId = null) {
      tg?.HapticFeedback?.impactOccurred?.('light');
      pendingImageBase64 = null;
      const form = document.getElementById('wishForm');
      form.reset();
      document.getElementById('wishId').value = '';
      document.getElementById('imgPreview').style.display = 'none';
      document.getElementById('imgUploadText').textContent = 'Нажми или перетащи фото';
      ['imgError','nameError','linkError','priceError','sizeError'].forEach((id) => {
        const el = document.getElementById(id);
        if (el) { el.style.display = 'none'; el.textContent = ''; }
      });
      document.getElementById('wishModalTitle').textContent = editId ? 'Редактировать желание' : 'Добавить желание';
      
      // Отключаем предупреждение при открытии пустой формы (будет включено при вводе данных)
      updateClosingConfirmation();
      
      document.querySelectorAll('.form-group label').forEach((label) => {
        label.style.color = '';
        const text = label.textContent.replace(/\s*\(автозаполнено\)/g, '');
        label.textContent = text;
      });

      const sel = document.getElementById('wishCategory');
      sel.innerHTML = '<option value="">Без категории</option>' +
        categories.map((c) => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');

      const wlSelect = document.getElementById('wishWishlistSelect');
      const initialIds = editId ? (wishes.find((x) => x.id === editId)?.wishlistIds || []) : (defaultWlId ? [defaultWlId] : []);
      const selectedIds = new Set(Array.isArray(initialIds) ? initialIds : []);
      const editableWishlists = wishlists.filter((wl) => !wl.isFollowedPublic);
      const renderMultiselect = () => {
        const names = editableWishlists.filter((wl) => selectedIds.has(wl.id)).map((wl) => wl.name);
        trigger.innerHTML = names.length > 0
          ? names.map((n) => `<span class="multiselect-chip">${escapeHtml(n)}</span>`).join('')
          : '<span class="multiselect-placeholder">Выберите вишлисты</span>';
        panel.querySelectorAll('.multiselect-option').forEach((opt) => opt.classList.toggle('selected', selectedIds.has(opt.dataset.id)));
      };
      wlSelect.innerHTML = editableWishlists.length === 0
        ? '<span style="color:var(--text-secondary);font-size:0.9rem;">Нет вишлистов</span>'
        : `<div class="multiselect-trigger" id="wlMultiselectTrigger"></div>
           <div class="multiselect-panel" id="wlMultiselectPanel">
             ${editableWishlists.map((wl) => `<div class="multiselect-option" data-id="${escapeHtml(wl.id)}">${escapeHtml(wl.name)}</div>`).join('')}
           </div>`;
      const trigger = document.getElementById('wlMultiselectTrigger');
      const panel = document.getElementById('wlMultiselectPanel');
      if (trigger && panel) {
        trigger.addEventListener('click', (e) => { e.stopPropagation(); wlSelect.classList.toggle('open'); });
        panel.querySelectorAll('.multiselect-option').forEach((opt) => {
          opt.addEventListener('click', (e) => {
            e.stopPropagation();
            const id = opt.dataset.id;
            if (selectedIds.has(id)) selectedIds.delete(id); else selectedIds.add(id);
            renderMultiselect();
          });
        });
        document.addEventListener('click', () => wlSelect.classList.remove('open'), { once: true });
        wlSelect._getSelectedIds = () => [...selectedIds];
        renderMultiselect();
      }

      if (editId) {
        const w = wishes.find((x) => x.id === editId);
        if (w) {
          document.getElementById('wishId').value = w.id;
          document.getElementById('wishName').value = w.name || '';
          document.getElementById('wishPrice').value = w.price || '';
          document.getElementById('wishCurrency').value = w.currency || '';
          document.getElementById('wishSize').value = w.size || '';
          document.getElementById('wishLink').value = w.link || '';
          document.getElementById('wishComment').value = w.comment || '';
          document.getElementById('wishCategory').value = w.category || '';
          if (w.image) {
            pendingImageBase64 = w.image;
            document.getElementById('imgPreview').src = w.image;
            document.getElementById('imgPreview').style.display = 'block';
            document.getElementById('imgUploadText').textContent = 'Изменить фото';
          }
        }
      }
      updateCounters();
      document.getElementById('wishModal').classList.add('open');
    }

    function closeWishModal() {
      document.getElementById('wishModal').classList.remove('open');
      // Отключаем предупреждение при закрытии модалки
      updateClosingConfirmation();
    }

    function updateCounters() {
      document.getElementById('nameCounter').textContent = `${(document.getElementById('wishName').value || '').length}/100`;
      document.getElementById('commentCounter').textContent = `${(document.getElementById('wishComment').value || '').length}/500`;
    }

    document.getElementById('wishName').addEventListener('input', () => { updateCounters(); updateClosingConfirmation(); });
    document.getElementById('wishComment').addEventListener('input', () => { updateCounters(); updateClosingConfirmation(); });
    
    // Отслеживаем изменения в других полях формы для предупреждения о закрытии
    ['wishLink', 'wishPrice', 'wishSize', 'wishWishlist'].forEach((id) => {
      const el = document.getElementById(id);
      if (el) {
        el.addEventListener('input', updateClosingConfirmation);
        el.addEventListener('change', updateClosingConfirmation);
      }
    });
    
    // Отслеживаем загрузку изображения
    document.getElementById('wishImage')?.addEventListener('change', (e) => {
      if (e.target.files && e.target.files[0]) {
        updateClosingConfirmation();
      }
    });

    document.getElementById('imgUpload').addEventListener('click', () => document.getElementById('wishImage').click());
    document.getElementById('imgUpload').addEventListener('dragover', (e) => { e.preventDefault(); document.getElementById('imgUpload').classList.add('dragover'); });
    document.getElementById('imgUpload').addEventListener('dragleave', () => document.getElementById('imgUpload').classList.remove('dragover'));
    document.getElementById('imgUpload').addEventListener('drop', (e) => {
      e.preventDefault();
      document.getElementById('imgUpload').classList.remove('dragover');
      const f = e.dataTransfer?.files?.[0];
      if (f && f.type.startsWith('image/')) handleImageFile(f);
    });
    document.getElementById('wishImage').addEventListener('change', (e) => {
      const f = e.target.files?.[0];
      if (f) handleImageFile(f);
    });

    async function handleImageFile(file) {
      document.getElementById('imgError').style.display = 'none';
      try {
        let b64 = await fileToBase64(file);
        b64 = await resizeImageBase64(b64);
        pendingImageBase64 = b64;
        document.getElementById('imgPreview').src = b64;
        document.getElementById('imgPreview').style.display = 'block';
        document.getElementById('imgUploadText').textContent = 'Изменить фото';
        updateClosingConfirmation();
      } catch (e) {
        document.getElementById('imgError').textContent = 'Не удалось загрузить изображение';
        document.getElementById('imgError').style.display = 'block';
      }
    }

    document.getElementById('wishForm').addEventListener('submit', (async (e) => {
      e.preventDefault();
      const id = document.getElementById('wishId').value;
      const isNew = !id;
      const name = document.getElementById('wishName').value.trim();
      const price = document.getElementById('wishPrice').value;
      const currency = document.getElementById('wishCurrency').value;
      const size = document.getElementById('wishSize').value.trim();
      const link = document.getElementById('wishLink').value.trim();
      const comment = document.getElementById('wishComment').value.trim();
      const category = document.getElementById('wishCategory').value || undefined;
      const wlSel = document.getElementById('wishWishlistSelect');
      const wishlistIds = wlSel?._getSelectedIds ? wlSel._getSelectedIds() : [];

      ['imgError','nameError','linkError','priceError','sizeError'].forEach((id) => {
        const el = document.getElementById(id);
        if (el) { el.style.display = 'none'; el.textContent = ''; }
      });

      if (isNew && !pendingImageBase64) {
        document.getElementById('imgError').textContent = 'Добавьте изображение';
        document.getElementById('imgError').style.display = 'block';
        return;
      }
      const nameErr = validateName(name);
      if (nameErr) {
        document.getElementById('nameError').textContent = nameErr;
        document.getElementById('nameError').style.display = 'block';
        return;
      }
      const linkErr = validateLink(link);
      if (linkErr) {
        document.getElementById('linkError').textContent = linkErr;
        document.getElementById('linkError').style.display = 'block';
        return;
      }
      const priceErr = validatePrice(price);
      if (priceErr && price) {
        document.getElementById('priceError').textContent = priceErr;
        document.getElementById('priceError').style.display = 'block';
        return;
      }
      const sizeErr = validateSize(size);
      if (sizeErr) {
        document.getElementById('sizeError').textContent = sizeErr;
        document.getElementById('sizeError').style.display = 'block';
        return;
      }

      const payload = {
        id: id || 'w_' + Date.now(),
        name,
        image: pendingImageBase64 || (wishes.find((x) => x.id === id)?.image),
        price: price ? String(parseInt(price, 10)) : undefined,
        currency: currency || undefined,
        size: size || undefined,
        link: link || undefined,
        comment: comment || undefined,
        category,
        wishlistIds,
      };

      const idx = wishes.findIndex((x) => x.id === payload.id);
      if (idx >= 0) wishes[idx] = { ...wishes[idx], ...payload };
      else wishes.push(payload);

      wishlistIds.forEach((wlId) => { const wl = wishlists.find((x) => x.id === wlId); if (wl) wl.updatedAt = Date.now(); });
      await saveWishes();
      await saveWishlists();
      render();
      closeWishModal();
      // Отключаем предупреждение после сохранения
      updateClosingConfirmation();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    }));

    async function deleteWish(id) {
      tg?.HapticFeedback?.impactOccurred?.('medium');
      wishes = wishes.filter((x) => x.id !== id);
      await saveWishes();
      render();
    }

    document.getElementById('wishCancel').addEventListener('click', closeWishModal);
    document.getElementById('wishModal').addEventListener('click', (e) => {
      if (e.target.id === 'wishModal') closeWishModal();
    });

    function openCatsModal() {
      tg?.HapticFeedback?.impactOccurred?.('light');
      const list = document.getElementById('catList');
      list.innerHTML = categories.length === 0
        ? '<div class="empty-cats">Категорий нет. Добавь свою.</div>'
        : categories.map((c) => `
            <div class="cat-item" data-cat="${escapeHtml(c)}">
              <span>${escapeHtml(c)}</span>
              <span class="cat-item-remove" data-cat="${escapeHtml(c)}">✕</span>
            </div>`).join('');
      list.querySelectorAll('.cat-item-remove').forEach((el) => {
        el.addEventListener('click', async () => {
          categories = categories.filter((x) => x !== el.dataset.cat);
          await saveCategories();
          openCatsModal();
        });
      });
      document.getElementById('newCatName').value = '';
      document.getElementById('catsModal').classList.add('open');
    }

    document.getElementById('catsClose').addEventListener('click', () => document.getElementById('catsModal').classList.remove('open'));
    document.getElementById('catsModal').addEventListener('click', (e) => {
      if (e.target.id === 'catsModal') e.target.classList.remove('open');
    });

    document.getElementById('addCatBtn').addEventListener('click', async () => {
      const v = document.getElementById('newCatName').value.trim();
      if (!v) return;
      const re = /^[a-zA-Zа-яА-ЯёЁ0-9\s\-_]+$/;
      if (!re.test(v)) return;
      if (categories.includes(v)) return;
      categories.push(v);
      await saveCategories();
      document.getElementById('newCatName').value = '';
      openCatsModal();
    });

    document.getElementById('newCatName').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') document.getElementById('addCatBtn').click();
    });

    function openWlModal() {
      tg?.HapticFeedback?.impactOccurred?.('light');
      document.getElementById('wlAddForm').style.display = 'block';
      document.getElementById('wlEditForm').style.display = 'none';
      editingWlId = null;
      pendingWlImageBase64 = null;
      document.getElementById('wlImgPreview').style.display = 'none';
      document.getElementById('wlImgText').textContent = 'Добавить обложку (необязательно)';
      const list = document.getElementById('wlList');
      list.innerHTML = wishlists.length === 0
        ? '<div class="empty-cats">Вишлистов нет. Добавь первый.</div>'
        : wishlists.map((wl) => {
            const pr = wl.privacy === 'private' ? 'Приватный' : (wl.privacy === 'public' ? 'Публичный' : 'Совместный');
            const isCollab = wl.privacy === 'shared' && canEditWishlist(wl) && !isOwner(wl);
            const isFollowed = !!wl.isFollowedPublic;
            const removeOrLeave = (isCollab || isFollowed)
              ? `<span class="wl-item-leave" data-wl-id="${escapeHtml(wl.id)}" data-followed="${isFollowed}" style="color:var(--accent);cursor:pointer;padding:4px;font-size:0.85rem;">Покинуть</span>`
              : (isOwner(wl) ? `<span class="wl-item-remove" data-wl-id="${escapeHtml(wl.id)}">✕</span>` : '');
            const editBtn = isFollowed ? '' : `<span class="wl-item-edit" data-wl-id="${escapeHtml(wl.id)}" title="Редактировать">✎</span>`;
            return `
            <div class="wl-item" data-wl-id="${escapeHtml(wl.id)}">
              ${wl.image ? `<img class="wl-item-img" src="${escapeHtml(wl.image)}" alt="">` : '<div class="wl-item-img" style="background:var(--border);flex-shrink:0;"></div>'}
              <div class="wl-item-body">
                <div>${escapeHtml(wl.name)}</div>
                <span class="privacy-badge" style="font-size:0.7rem;margin-top:4px;display:inline-block;">${escapeHtml(pr)}</span>
              </div>
              ${editBtn}
              ${removeOrLeave}
            </div>`;
          }).join('');
      list.querySelectorAll('.wl-item-edit').forEach((el) => {
        el.addEventListener('click', () => openEditWlForm(el.dataset.wlId));
      });
      list.querySelectorAll('.wl-item-leave').forEach((el) => {
        el.addEventListener('click', async () => {
          const wlId = el.dataset.wlId;
          if (el.dataset.followed === 'true') {
            await leaveFollowedPublicWishlist(wlId);
            if (useSupabase && sb) { const r = await loadWishlistsFromSupabase(); if (r.data) wishlists = r.data; } else wishlists = wishlists.filter((x) => x.id !== wlId);
          } else {
            await leaveWishlist(el.dataset.wlId);
          }
          openWlModal();
        });
      });
      list.querySelectorAll('.wl-item-remove').forEach((el) => {
        el.addEventListener('click', async () => {
          const wlId = el.dataset.wlId;
          wishes.forEach((w) => {
            const ids = Array.isArray(w.wishlistIds) ? w.wishlistIds : [];
            w.wishlistIds = ids.filter((id) => id !== wlId);
          });
          wishlists = wishlists.filter((x) => x.id !== wlId);
          await saveWishlists();
          await saveWishes();
          openWlModal();
        });
      });
      document.getElementById('newWlName').value = '';
      document.getElementById('wlModal').classList.add('open');
    }

    document.getElementById('wlClose').addEventListener('click', () => document.getElementById('wlModal').classList.remove('open'));
    document.getElementById('wlModal').addEventListener('click', (e) => {
      if (e.target.id === 'wlModal') e.target.classList.remove('open');
    });

    document.getElementById('wlImgUpload').addEventListener('click', () => document.getElementById('wlImage').click());
    document.getElementById('wlImage').addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f || !f.type.startsWith('image/')) return;
      try {
        let b64 = await fileToBase64(f);
        b64 = await resizeImageBase64(b64, 400);
        pendingWlImageBase64 = b64;
        document.getElementById('wlImgPreview').src = b64;
        document.getElementById('wlImgPreview').style.display = 'block';
        document.getElementById('wlImgText').textContent = 'Изменить обложку';
      } catch (_) {}
    });

    document.getElementById('addWlBtn').addEventListener('click', async () => {
      const name = document.getElementById('newWlName').value.trim();
      if (!name) return;
      const wl = {
        id: 'wl_' + Date.now(),
        name,
        image: pendingWlImageBase64 || undefined,
        privacy: document.getElementById('newWlPrivacy').value || 'private',
        ownerId: currentUserId,
        coAuthorIds: [currentUserId],
      };
      wishlists.push(wl);
      await saveWishlists();
      pendingWlImageBase64 = null;
      document.getElementById('newWlName').value = '';
      document.getElementById('wlImgPreview').style.display = 'none';
      document.getElementById('wlImgText').textContent = 'Добавить обложку (необязательно)';
      document.getElementById('wlImage').value = '';
      openWlModal();
      render();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    });

    async function openEditWlForm(wlId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl) return;
      editingWlId = wlId;
      pendingEditWlImage = null;
      document.getElementById('wlAddForm').style.display = 'none';
      document.getElementById('wlEditForm').style.display = 'block';
      document.getElementById('editWlName').value = wl.name || '';
      document.getElementById('editWlPrivacy').value = wl.privacy || 'private';
      document.getElementById('wlImgPreviewEdit').style.display = 'none';
      document.getElementById('wlImgTextEdit').textContent = 'Обложка';
      if (wl.image) {
        document.getElementById('wlImgPreviewEdit').src = wl.image;
        document.getElementById('wlImgPreviewEdit').style.display = 'block';
        document.getElementById('wlImgTextEdit').textContent = 'Изменить обложку';
      }
      const extras = document.getElementById('wlEditFormExtras');
      extras.innerHTML = '';
      const isCollab = wl.privacy === 'shared' && canEditWishlist(wl) && !isOwner(wl);
      if (isCollab) {
        extras.innerHTML = '<button type="button" class="btn btn-secondary" id="editWlLeave" style="margin-top:12px;">Покинуть вишлист</button>';
        document.getElementById('editWlLeave').addEventListener('click', async () => { await leaveWishlist(wlId); document.getElementById('wlModal').classList.remove('open'); openWlModal(); });
      } else if (wl.privacy === 'shared' && isOwner(wl)) {
        const coAuths = (wl.coAuthorIds || []).filter((id) => id !== (wl.ownerId || wl.owner_id));
        if (coAuths.length > 0) {
          const names = await Promise.all(coAuths.map(async (uid) => {
            if (useSupabase && sb) {
              const { data } = await sb.from('users').select('first_name, username').eq('id', uid).single();
              return data ? (data.username ? '@' + data.username : data.first_name || uid) : uid;
            }
            return uid;
          }));
          extras.innerHTML = `
            <div class="form-group" style="margin-top:12px;">
              <label>Удалить соавтора</label>
              <select id="editWlRemoveCollab" style="width:100%;padding:8px 12px;margin-top:4px;border-radius:8px;background:var(--bg-card);color:var(--text-primary);border:1px solid var(--border);">
                <option value="">— Выберите —</option>
                ${coAuths.map((id, i) => `<option value="${escapeHtml(id)}">${escapeHtml(names[i] || id)}</option>`).join('')}
              </select>
              <button type="button" class="btn btn-secondary btn-sm" id="editWlRemoveCollabBtn" style="margin-top:8px;">Удалить</button>
            </div>`;
          document.getElementById('editWlRemoveCollabBtn').addEventListener('click', async () => {
            const uid = document.getElementById('editWlRemoveCollab').value;
            if (!uid) return;
            await removeCollaborator(wlId, uid);
            openEditWlForm(wlId);
          });
        }
      }
    }

    document.getElementById('editWlCancel').addEventListener('click', () => {
      editingWlId = null;
      document.getElementById('wlAddForm').style.display = 'block';
      document.getElementById('wlEditForm').style.display = 'none';
      openWlModal();
    });

    document.getElementById('editWlSave').addEventListener('click', async () => {
      if (!editingWlId) return;
      const wl = wishlists.find((x) => x.id === editingWlId);
      if (!wl) return;
      const name = document.getElementById('editWlName').value.trim();
      if (!name) return;
      wl.name = name;
      wl.privacy = document.getElementById('editWlPrivacy').value || 'private';
      if (pendingEditWlImage) wl.image = pendingEditWlImage;
      await saveWishlists();
      editingWlId = null;
      document.getElementById('wlAddForm').style.display = 'block';
      document.getElementById('wlEditForm').style.display = 'none';
      openWlModal();
      render();
      tg?.HapticFeedback?.notificationOccurred?.('success');
    });

    document.getElementById('wlImgUploadEdit').addEventListener('click', () => document.getElementById('wlImageEdit').click());
    document.getElementById('wlImageEdit').addEventListener('change', async (e) => {
      const f = e.target.files?.[0];
      if (!f || !f.type.startsWith('image/')) return;
      try {
        let b64 = await fileToBase64(f);
        b64 = await resizeImageBase64(b64, 400);
        pendingEditWlImage = b64;
        document.getElementById('wlImgPreviewEdit').src = b64;
        document.getElementById('wlImgPreviewEdit').style.display = 'block';
        document.getElementById('wlImgTextEdit').textContent = 'Изменить обложку';
      } catch (_) {}
    });

    function buildShareUrl(type, wlId, payload) {
      if (TELEGRAM_BOT && TELEGRAM_APP) {
        const param = type === 'share' ? 'w_' + wlId : 'i_' + wlId;
        return 'https://t.me/' + TELEGRAM_BOT + '/' + TELEGRAM_APP + '?startapp=' + param;
      }
      const base = window.location.origin + window.location.pathname;
      return (useSupabase && sb) ? base + (type === 'share' ? '#w/' : '#i/') + wlId : base + '#' + packPayload(payload);
    }

    function openShareModal(wlId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl || wl.privacy !== 'public') return;
      const ownerName = tg?.initDataUnsafe?.user?.username ? '@' + tg.initDataUnsafe.user.username : (tg?.initDataUnsafe?.user?.first_name || 'Пользователь');
      const url = buildShareUrl('share', wlId, { type: 'public', wishlist: wl, wishes: wishes.filter((w) => (w.wishlistIds || []).includes(wlId)), reservedCards: {}, ownerName });
      if (tg?.openTelegramLink) {
        const text = `Посмотри мой вишлист «${wl.name || 'Вишлист'}»!`;
        tg.openTelegramLink('https://t.me/share/url?url=' + encodeURIComponent(url) + '&text=' + encodeURIComponent(text));
      } else {
        document.getElementById('shareWlLink').textContent = url;
        document.getElementById('shareWlHint').style.display = (TELEGRAM_BOT && TELEGRAM_APP) ? 'none' : 'block';
        document.getElementById('shareWlModal').classList.add('open');
      }
    }

    function openInviteModal(wlId) {
      const wl = wishlists.find((x) => x.id === wlId);
      if (!wl || wl.privacy !== 'shared') return;
      const invOwnerName = tg?.initDataUnsafe?.user?.username ? '@' + tg.initDataUnsafe.user.username : (tg?.initDataUnsafe?.user?.first_name || 'Пользователь');
      const url = buildShareUrl('invite', wlId, { type: 'invite', wishlist: { ...wl, coAuthorIds: wl.coAuthorIds || [wl.ownerId] }, wishes: wishes.filter((w) => (w.wishlistIds || []).includes(wlId)), ownerName: invOwnerName });
      if (tg?.openTelegramLink) {
        const text = `Присоединяйся к вишлисту «${wl.name || 'Вишлист'}» как соавтор!`;
        tg.openTelegramLink('https://t.me/share/url?url=' + encodeURIComponent(url) + '&text=' + encodeURIComponent(text));
      } else {
        document.getElementById('inviteWlLink').textContent = url;
        document.getElementById('inviteWlHint').style.display = (TELEGRAM_BOT && TELEGRAM_APP) ? 'none' : 'block';
        document.getElementById('inviteWlModal').classList.add('open');
      }
    }

    document.getElementById('shareWlClose').addEventListener('click', () => document.getElementById('shareWlModal').classList.remove('open'));
    document.getElementById('shareWlCopy').addEventListener('click', () => {
      navigator.clipboard?.writeText(document.getElementById('shareWlLink').textContent);
      tg?.HapticFeedback?.notificationOccurred?.('success');
      document.getElementById('shareWlCopy').textContent = 'Скопировано!';
      setTimeout(() => { document.getElementById('shareWlCopy').textContent = 'Копировать'; }, 2000);
    });
    document.getElementById('shareWlModal').addEventListener('click', (e) => { if (e.target.id === 'shareWlModal') e.target.classList.remove('open'); });

    document.getElementById('shareWelcomeOk').addEventListener('click', () => {
      document.getElementById('shareWelcomeModal').classList.remove('open');
    });

    document.getElementById('inviteConsentAccept').addEventListener('click', async () => {
      if (!pendingInviteData) return;
      const next = { ...pendingInviteData };
      pendingInviteData = null;
      document.getElementById('inviteConsentModal').classList.remove('open');
      if (next.fullPayload && !useSupabase) {
        await handleInviteJoin(next.fullPayload);
      } else if (useSupabase && sb) {
        await ensureUser();
        await sb.from('wishlist_collaborators').upsert({ wishlist_id: next.wlId, user_id: currentUserId }, { onConflict: 'wishlist_id,user_id' });
        sessionStorage.setItem('accepted_invite_' + next.wlId, '1');
      }
      window.location.reload();
    });

    document.getElementById('inviteConsentDecline').addEventListener('click', () => {
      if (!pendingInviteData) return;
      const wlId = pendingInviteData.wlId;
      pendingInviteData = null;
      document.getElementById('inviteConsentModal').classList.remove('open');
      sessionStorage.setItem('declined_invite_' + wlId, '1');
      window.location.reload();
    });

    document.getElementById('inviteWlClose').addEventListener('click', () => document.getElementById('inviteWlModal').classList.remove('open'));
    document.getElementById('inviteWlCopy').addEventListener('click', () => {
      navigator.clipboard?.writeText(document.getElementById('inviteWlLink').textContent);
      tg?.HapticFeedback?.notificationOccurred?.('success');
      document.getElementById('inviteWlCopy').textContent = 'Скопировано!';
      setTimeout(() => { document.getElementById('inviteWlCopy').textContent = 'Копировать'; }, 2000);
    });
    document.getElementById('inviteWlModal').addEventListener('click', (e) => { if (e.target.id === 'inviteWlModal') e.target.classList.remove('open'); });

    (async function init() {
      let content;
      try {
        content = document.getElementById('content');
        if (!content) { document.body.insertAdjacentHTML('beforeend', '<div id="content" style="padding:16px;"></div>'); content = document.getElementById('content'); }
        currentView = 'main';
        if (!Array.isArray(wishlists)) wishlists = [];
        if (!Array.isArray(wishes)) wishes = [];
        if (!Array.isArray(categories)) categories = [...DEFAULT_CATS];
        render();
      } catch (e) {
        console.error('Init/render error:', e);
        const c = document.getElementById('content');
        if (c) c.innerHTML = '<p style="padding:24px;color:var(--accent);">Ошибка: ' + String(e && e.message || e).slice(0, 100) + '</p><button class="btn" onclick="location.reload()">Обновить</button>';
        return;
      }
      const fallbackToLocal = function() {
        publicViewData = null;
        currentView = 'main';
        if (useSupabase) {
          wishes = []; wishlists = []; categories = [...DEFAULT_CATS];
        } else {
          try { wishes = JSON.parse(safeGetItem(WISHES_KEY) || '[]').map(migrateWish); } catch (_) { wishes = []; }
          try { wishlists = (JSON.parse(safeGetItem(WISHLISTS_KEY) || '[]')).map(migrateWishlist); } catch (_) { wishlists = []; }
          try { const r = safeGetItem(CATS_KEY); categories = r ? JSON.parse(r) : [...DEFAULT_CATS]; } catch (_) { categories = [...DEFAULT_CATS]; }
        }
        if (!Array.isArray(wishlists)) wishlists = [];
        if (!Array.isArray(wishes)) wishes = [];
        if (!Array.isArray(categories)) categories = [...DEFAULT_CATS];
      };
      try {
        const loadPromise = loadAll();
        const timeout = new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), 8000));
        await Promise.race([loadPromise, timeout]);
      } catch (e) {
        console.error('Load error:', e);
        fallbackToLocal();
      }
      currentView = 'main';
      if (window._supabaseLoadError) {
        const raw = String(window._supabaseLoadError);
        const msg = raw.length > 200 ? raw.slice(0, 200) + '…' : raw;
        const safe = msg.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
        content.innerHTML = '<p style="text-align:center;padding:24px;color:var(--accent);">Ошибка Supabase: ' + safe + '</p><p style="text-align:center;font-size:0.85rem;color:var(--text-secondary);">Проверь RLS: выполни supabase-disable-rls.sql в SQL Editor.</p><button class="btn" style="margin:16px auto;display:block;" onclick="location.reload()">Обновить</button>';
        return;
      }
      try {
        render();
      } catch (e) {
        console.error('Render error:', e);
        fallbackToLocal();
        try { render(); } catch (_) {
          content.innerHTML = '<p style="text-align:center;padding:24px;color:var(--text-secondary);">Не удалось загрузить интерфейс.</p><button class="btn" style="margin:0 auto;display:block;" onclick="location.reload()">Обновить</button>';
        }
      }
    })();
  </script>
</body>
</html>
