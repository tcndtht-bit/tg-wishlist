# Аудит быстродействия и план рефакторинга

**Цель:** значительно ускорить все этапы: открытие мини-апп, появление кнопки анализа и карточки, анализ по изображению/ссылке, ответы бота.

---

## 1. Цепочки взаимодействий (общая картина)

```
[Пользователь]
     │
     ├─ Открывает мини-апп (без start_param)
     │       → index.html загружается
     │       → init() → render() (скелетон) → loadAll()
     │       → ensureLzString() [CDN] → loadSupabase() [CDN] → ensureUser() + loadWishlists + loadWishes + loadCategories
     │       → после всего: isLoading=false, render() → кнопки «По фото» / «По ссылке»
     │
     ├─ Открывает мини-апп по ссылке из бота (start_param: img_ / link_ / text_)
     │       → то же loadAll() в ветке img_/link_/text_
     │       → loadDataThenOpen(): те же Supabase-запросы (до 8 сек), потом openWishModal…
     │       → кнопки появляются только после loadDataThenOpen()
     │
     ├─ В мини-аппе: «Добавить по фото»
     │       → fileToBase64 → resizeImageBase64(1280) → overlay → fetch POST /analyze-image (base64)
     │       → link-scraper: analyzeImage(Vision API) + загрузка в Supabase Storage → ответ
     │       → openWishModalFromImage()
     │
     ├─ В мини-аппе: «Добавить по ссылке»
     │       → overlay → fetch GET /?url=…
     │       → link-scraper: Puppeteer launch → goto → 1.5s wait → content → parse → [DOM override] → fetch картинки → base64
     │       → openWishModalFromLink()
     │
     └─ В боте: отправка ссылки
             → бот вызывает GET link-scraper/?url=… (тот же Puppeteer-пайплайн)
             → бот ждёт ответа → отправляет сообщение с карточкой и кнопкой «Оформить»
```

---

## 2. Проблема 1: Медленная прогрузка кнопки анализа и предзаполненной карточки при анализе по изображению

**Где:** мини-апп → «Добавить по фото» → выбор файла → до появления карточки.

**Причины:**
- **Клиент:** `resizeImageBase64(1280, 0.85)` на большом файле занимает время; один большой JSON с base64 уходит на сервер.
- **Сервер (link-scraper):** `POST /analyze-image` последовательно:
  1. Вызов Vision API (Groq/OpenRouter/Gemini) — 1–4+ сек.
  2. Загрузка того же base64 в Supabase Storage — ещё 0.5–2 сек.
- Ответ отдаётся только после обоих шагов.

**Итог:** Пользователь видит overlay «Анализируем изображение…» 3–7+ сек.

---

## 3. Проблема 2: Очень медленное (6–7 сек) появление кнопки анализа при открытии по ссылке из бота; карточка появляется нормально

**Где:** Открытие мини-апп с `start_param` вида `img_`, `link_`, `text_` (переход из бота).

**Причина:** В `loadAll()` при таком start_param:
1. Ставится `isLoading = true`, делается один `render()` (скелетон).
2. Запускается `loadDataThenOpen()`:
   - `ensureUser()` (1 запрос);
   - `loadWishlistsFromSupabase()` (несколько запросов);
   - `loadWishesFromSupabase()` (зависит от вишлистов);
   - `loadCategoriesFromSupabase()` (1 запрос);
   - таймаут 8 сек в `Promise.race`.
3. Только после всего: `isLoading = false`, `render()` — появляются кнопки главной.
4. Затем вызывается `openWishModalFromImage/FromLink/FromText` — карточка открывается быстро.

Кнопки «Добавить по фото» / «По ссылке» показываются только после полной загрузки данных с Supabase. Данные для модалки (payload из start_param) уже есть, но UI не показывается до конца загрузки.

**Итог:** 6–7 сек пользователь видит скелетон, хотя для открытия карточки данные из start_param уже готовы.

---

## 4. Проблема 3: Открытие мини-апп, ответы бота и общая скорость

**Открытие мини-апп (без start_param):**
- Тот же `loadAll()`: сначала `ensureLzString()` (загрузка LZString с CDN), затем `loadSupabase()` (Supabase с CDN), затем цепочка Supabase-запросов.
- Первый интерактивный экран (кнопки) — только после завершения `loadAll()` или срабатывания таймаута 5 сек в `init()`.
- LZString нужен в основном для `unpackPayload(hash)` (публичная ссылка / инвайт по hash), но вызывается при каждом старте.

**Ответы бота при отправке ссылки:**
- Бот (вне репозитория) вызывает link-scraper `GET /?url=…`.
- Scraper каждый раз: `puppeteer.launch()` → новая страница → `goto` (до 25 сек) → ожидание 1.5 сек → парсинг → при необходимости `page.evaluate` → загрузка картинки по URL (до 10 сек) и конвертация в base64.
- Ответ бота = время ответа scraper’а (часто 4–10+ сек).

**Общее ощущение:** много последовательных шагов и ожиданий; ничего не отдаётся пользователю до полного завершения.

---

## 5. Узкие места по компонентам

### 5.1 Мини-апп (index.html)

| Узкое место | Влияние |
|-------------|--------|
| `loadAll()` блокирует показ главного экрана | Кнопки «По фото» / «По ссылке» появляются только после LZString + Supabase + все запросы (или 5 сек). |
| `ensureLzString()` в начале `loadAll()` | Доп. CDN-запрос при каждом старте, хотя LZString нужен только при открытии по hash (share/invite). |
| При start_param img_/link_/text_: полная загрузка данных до показа UI | Кнопки появляются через 6–8 сек, хотя payload уже есть. |
| Один большой скрипт (~3000+ строк) | Дольше парсинг и выполнение на слабых устройствах. |
| Анализ по фото: один тяжёлый запрос | Нет прогресса; пользователь не понимает, на каком этапе задержка (Vision vs Supabase). |

### 5.2 Link-scraper (server.js)

| Узкое место | Влияние |
|-------------|--------|
| `puppeteer.launch()` на каждый запрос GET / | Холодный старт браузера 1–3 сек; нет переиспользования. |
| `waitUntil: 'networkidle2'` + явные 1.5 сек | Страница ждётся долго; для многих сайтов достаточно `domcontentloaded` + короткой задержки. |
| Загрузка картинки товара и конвертация в base64 перед ответом | Доп. 1–4 сек; клиент мог бы брать `image` URL сам. |
| POST /analyze-image: Vision API, затем Supabase upload, затем ответ | Ответ задерживается на время загрузки в Storage. |
| Таймаут 25 сек для страницы | Долгое ожидание при «тяжёлых» сайтах. |

### 5.3 Бот (вне репозитория)

| Узкое место | Влияние |
|-------------|--------|
| Ожидание ответа scraper’а перед отправкой сообщения | Пользователь не видит обратной связи 4–10+ сек. |
| Нет «типинга» или промежуточного сообщения | Ощущение «зависания». |

---

## 6. План рефакторинга (приоритеты)

### Фаза 1: Быстрые победы (мини-апп)

1. **Показать главный экран с кнопками до окончания loadAll()**
   - В `init()`: первый `render()` уже рисует скелетон (сейчас так и есть), но после таймаута 5 сек вызывается `fallbackToLocal()` и тогда `isLoading = false` и показ кнопок.
   - Сделать: **сразу** после первого `render()` (скелетон) считать «интерактивный скелетон» готовым и показывать кнопки «По фото» / «По ссылке» **сразу**, а список «Недавно изменённые» и данные подгружать в фоне. То есть не ждать `loadAll()` для отрисовки кнопок — только для заполнения списка вишлистов.
   - Альтернатива: выставить `isLoading = false` для главного экрана через короткий таймаут (например 300–500 мс), отрисовать кнопки, а данные подгружать асинхронно и обновлять список при получении.

2. **При открытии с start_param (img_ / link_ / text_) не ждать полной загрузки данных для показа кнопок**
   - Сделать: один раз `render()` с кнопками (или тем же скелетоном с кнопками), сразу запустить `loadDataThenOpen()` в фоне. Как только данные с Supabase загрузились (или таймаут) — обновить состояние и открыть модалку. Кнопки «Добавить по фото» / «По ссылке» видны с самого начала.
   - Итог: субъективно «кнопка анализа» появляется сразу; карточка по-прежнему открывается после загрузки данных.

3. **Отложить загрузку LZString**
   - Вызывать `ensureLzString()` только если в `loadAll()` реально нужен `unpackPayload(hash)` (например, при наличии hash и отсутствии префиксов w/, i/, start_param img_/link_/text_). Для пути «главная без hash» и для img_/link_/text_ LZString не трогать при старте.
   - Уменьшает блокирующий CDN-запрос при обычном открытии.

### Фаза 2: Анализ по изображению

4. **Link-scraper: не блокировать ответ analyze-image загрузкой в Supabase**
   - Вариант A: отдавать ответ с полями `name, price, currency, size, image: null` сразу после Vision API; загрузку в Storage запускать «в фоне» (не await перед `res.json`); если нужен `imageUrl` в карточке — либо второй запрос (GET по id), либо не отдавать imageUrl в первом ответе и показывать картинку из base64 в мини-апп (как сейчас при отсутствии imageUrl).
   - Вариант B: оставить загрузку в Supabase, но делать её параллельно с формированием ответа (например, запустить upload без await и отдать ответ с `image: null`, а когда upload завершится — клиент мог бы опционально запрашивать URL; или упростить и не отдавать imageUrl в первом ответе, а показывать переданное пользователем фото).
   - Цель: сократить время до первого ответа на 0.5–2 сек.

5. **Мини-апп: уменьшить размер и время отправки изображения**
   - Уже есть `resizeImageBase64(1280, 0.85)`. При необходимости снизить до 1024 или 800 по длинной стороне для ещё более быстрой отправки и меньшего времени Vision API.
   - Опционально: показывать в overlay этап («Отправляю фото», «Анализирую…») для лучшего UX.

### Фаза 3: Парсинг ссылок (link-scraper) и ответ бота

6. **Переиспользовать браузер Puppeteer**
   - Запускать браузер один раз при старте сервера (или пул из 1–2 инстансов) и для каждого запроса создавать только новую страницу (`browser.newPage()`). Закрывать страницу после ответа.
   - Сократит 1–3 сек на запрос (нет холодного launch).

7. **Сократить ожидание загрузки страницы**
   - Перейти на `waitUntil: 'domcontentloaded'` и уменьшить фиксированную задержку с 1500 до 500–800 мс для большинства сайтов; при необходимости увеличивать только для «тяжёлых» SPA (или по домену).
   - Уменьшит типичное время ответа на 0.5–1.5 сек.

8. **Не загружать картинку в base64 на сервере для ответа GET /**
   - В ответе GET / отдавать только `image: url` (URL картинки товара). Мини-апп и бот показывают карточку с этим URL (тег `img` с src). Не вызывать `page.goto(imgUrl)` и не конвертировать в base64 на scraper’е.
   - Экономия 1–4 сек на запрос и снижение нагрузки на сервер. Если бот или мини-апп где-то требуют именно base64 (например, превью в Telegram), можно оставить опциональный query-параметр `attachImage=1` и тогда один раз в запросе подгружать картинку.

9. **Бот: быстрая обратная связь**
   - При получении ссылки сразу отправить сообщение типа «Парсю ссылку…» (или показать «typing»), затем после ответа scraper’а отредактировать сообщение на карточку с кнопкой или отправить новое.
   - Реализация в репозитории бота; в этом репозитории только рекомендация.

### Фаза 4: Долгосрочные улучшения

10. **Сузить и параллелить запросы Supabase при загрузке**
    - В `loadWishlistsFromSupabase` уже есть параллельные запросы; проверить, что нет лишней последовательности.
    - В `loadAll()` для обычного входа: по возможности запускать `ensureUser()` и загрузку вишлистов параллельно с загрузкой скрипта Supabase (если удастся не блокировать первый рендер).

11. **Разбить index.html**
    - Вынести CSS и/или основной JS в отдельные файлы с отложенной загрузкой, чтобы быстрее первый отрисовывался контент и кнопки.

12. **Кэш в link-scraper (опционально)**
    - Кэшировать ответ GET / по URL на 1–5 минут (в памяти или Redis), чтобы повторные запросы той же ссылки (например, от разных пользователей) отдавались мгновенно.

---

## 7. Ожидаемый эффект по сценариям

| Сценарий | Сейчас | После рефакторинга (целево) |
|----------|--------|-----------------------------|
| Открытие мини-апп (главная) | 5–7 сек до кнопок | Кнопки видны за 0.3–1 сек; список вишлистов подгружается в фоне. |
| Открытие по ссылке из бота (img_/link_/text_) | 6–8 сек скелетон, потом кнопки + карточка | Кнопки сразу; карточка через 1–3 сек (после загрузки данных). |
| Анализ по фото в мини-апп | 3–7+ сек overlay | 2–4 сек за счёт ответа до/параллельно с Supabase upload и возможного уменьшения размера фото. |
| Парсинг ссылки в мини-апп | 4–10+ сек | 2–5 сек (reuse browser, меньше wait, без загрузки картинки в base64). |
| Ответ бота на ссылку | 4–10+ сек до сообщения | Та же длительность парсинга, но сразу «Парсю ссылку…» и затем карточка. |

---

## 8. Что не менять на первом этапе

- Логику парсинга (parse, json-ld, blob, DOM override) — уже настроена.
- Формат ответов API (поля name, price, currency, size, image, link) — менять только при необходимости (например, убрать imageBase64 из GET /).
- Бот живёт в отдельном репозитории — правки только в коде бота по документации/рекомендациям выше.

После согласования плана можно переходить к пошаговой реализации, начиная с Фазы 1 и пунктов 4–5 (анализ по изображению).
